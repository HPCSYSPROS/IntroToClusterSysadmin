#
#cmdline

lang en_US
network --onboot=yes --bootproto=dhcp --device=42:4d:e2:28:b4:72

#
# Where's the source?
# nfs --server hostname.of.server or IP --dir /path/to/RH/CD/image
#
#nfs --server  --dir 

%include /tmp/repos

#device ethernet e100
keyboard "us"

#
# Clear the MBR
#
zerombr

#
# Wipe out the disk
#
clearpart --all --initlabel
#clearpart --linux

#
# Customize to fit your needs
#

#XCAT_PARTITION_START#
# xCAT based partitioning
%include /tmp/partitionfile

#No RAID
#/boot really significant for this sort of setup nowadays?
#part /boot --size 50 --fstype ext3
#part swap --size 1024
#part / --size 1 --grow --fstype ext4

#RAID 0 /scr for performance
#part / --size 1024 --ondisk sda
#part swap --size 512 --ondisk sda
#part /var --size 1024 --ondisk sdb
#part swap --size 512 --ondisk sdb
#part raid.01 --size 1 --grow --ondisk sda
#part raid.02 --size 1 --grow --ondisk sdb
#raid /scr --level 0 --device md0 raid.01 raid.02

#Full RAID 1 Sample
#part raid.01 --size 50 --ondisk sda
#part raid.02 --size 50 --ondisk sdb
#raid /boot --level 1 --device md0 raid.01 raid.02
#
#part raid.11 --size 1024 --ondisk sda
#part raid.12 --size 1024 --ondisk sdb
#raid / --level 1 --device md1 raid.11 raid.12
#
#part raid.21 --size 1024 --ondisk sda
#part raid.22 --size 1024 --ondisk sdb
#raid /var --level 1 --device md2 raid.21 raid.22
#
#part raid.31 --size 1024 --ondisk sda
#part raid.32 --size 1024 --ondisk sdb
#raid swap --level 1 --device md3 raid.31 raid.32
#
#part raid.41 --size 1 --grow --ondisk sda
#part raid.42 --size 1 --grow --ondisk sdb
#raid /scr --level 1 --device md4 raid.41 raid.42
#XCAT_PARTITION_END#

#
# bootloader config
# --append <args>
# --useLilo
# --md5pass <crypted MD5 password for GRUB>
#
#The bootloader config here is commented out
#For user customized partition file or partition script,
#the bootloader configuration should be specified in the user customized partition file/script
#For the xCAT default partition scheme, the bootloader configuration is in /tmp/partitionfile
#which is generated in %pre section
#bootloader

#
# install or upgrade
#
install

#
# text mode install (default is graphical)
#
text

#
# firewall
#
firewall --disabled

#
# Select a zone
# Add the --utc switch if your hardware clock is set to GMT
#
#timezone US/Hawaii
#timezone US/Pacific
#timezone US/Mountain
#timezone US/Central
#timezone US/Eastern
timezone --utc "America/Denver"

#
# Don't do X
#
skipx


#
# To generate an encrypted root password use:
#
# perl -e 'print crypt("blah","Xa") . "\n";'p
# openssl passwd -apr1 -salt xxxxxxxx password
#
# where "blah" is your root password.
#
#rootpw --iscrypted XaLGAVe1C41x2
#rootpw XaLGAVe1C41x2 --iscrypted
rootpw --iscrypted $1$S8Rkpk4q$UpvAGwikadDYr0luwHzWf/

#
# NIS setup: auth --enablenis --nisdomain sensenet
# --nisserver neptune --useshadow --enablemd5
#
# OR
auth --useshadow --enablemd5

#
# SE Linux
#
selinux --disabled

#
# Reboot after installation
#
reboot

#
#end of section
#
%packages
#Please make sure there is a space between @ and group name
wget
ntp
nfs-utils
net-snmp
rsync
yp-tools
openssh-server
util-linux
net-tools
%end
%pre
{
echo "Running Kickstart Pre-Installation script..."
export XCATDEBUGMODE=""
if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set -x
fi
export MASTER_IP="192.168.122.1"
declare -F msgutil_r &>/dev/null  || function msgutil_r {
   local logserver=$1
   local msgtype=$2
   local msgstr=$3
   local logfile=$4
   local logtag=$5

   if [ -z "$msgtype"  ]; then
      msgtype="debug"
   fi

   if [ -z "$logtag" ]; then
      logtag="xcat"
   fi

   if [ -n "$logserver" ];then
      logger -n $logserver -t $logtag -p local4.$msgtype "$msgstr"
      if [ "$?" != "0" ];then
         exec 3<>/dev/udp/$logserver/514 >/dev/null;logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&3
         if [ "$?" != "0" ];then
            logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&1|nc $logserver 514 >/dev/null 2>&1
            if [ "$?" != "0" ];then
               logger -t $logtag -p local4.$msgtype "$msgstr"
            fi
         fi
      fi
   else
       logger -t $logtag -p local4.$msgtype "$msgstr"
   fi
   if [ -n "$logfile"  ]; then
      local logdir="$(dirname $logfile)"
      if [ ! -d "$logdir" ]; then
         mkdir -p "$logdir"
         touch "$logfile"
      fi

      echo "$(date) [$msgtype]: $logtag: $msgstr" >> $logfile
   fi

}

declare -F msgutil &>/dev/null  || function msgutil {
    msgutil_r "" "$@"
}

log_label="xcat.deployment"
msgutil_r "$MASTER_IP" "info" "============deployment starting============" "/var/log/xcat/xcat.log" "$log_label"
msgutil_r "$MASTER_IP" "info" "Running Anaconda Pre-Installation script..." "/var/log/xcat/xcat.log" "$log_label"
if grep n8r /proc/cmdline > /dev/null 2>&1;
then
  stty crtscts
fi
for x in 0 1 2 3 4 5 6 7 8
do
	mknod /dev/vcs$x c 7 $x
	mknod /dev/vcsa$x c 7 $[$x+128]
done
chmod 644 /dev/vcs*
chown root /dev/vcs*
if [ -r /tmp/updates/etc/pki/tls/certs/ca-bundle.crt ]; then
        cp -f /tmp/updates/etc/pki/tls/certs/ca-bundle.crt /etc/pki/tls/certs/
fi



cat >/tmp/baz.py <<EOF
#!/usr/bin/python
import socket
import sys

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('192.168.122.1',3002))

print sys.argv[1]
response = sock.recv(100)
if(response == "ready\n"):
        sock.send(sys.argv[1]+"\n")
        response = sock.recv(100)

sock.close()
EOF


cat >/tmp/foo.py <<EOF
#!/usr/bin/python

import socket
import os
import linecache
import re

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('192.168.122.1',3002))

response = sock.recv(100)
if(response == "ready\n"):
	sock.send("installmonitor\n")
	response = sock.recv(100)

sock.close()

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

port = 3054
sock.bind(('', port))

sock.listen(5)

try:
	while 1:
		newSocket, address = sock.accept()
		while 1:
			received = newSocket.recv(200)
			if not received:
				break
			command = re.split('\s+',received)
			if(command[0] == "stat"):
				ilog = ""
				line = ""
				post = 0
				percent = 0
				count = 0
				numpack = 0
				pre = 0
				if(os.path.isfile('/tmp/xcatpre.log')):
					ilog = '/tmp/xcatpre.log'
					pre = 1
				if(os.path.isfile('/tmp/packaging.log')):
					ilog = '/tmp/packaging.log'
				if(os.path.isfile('/mnt/sysimage/tmp/post.log')):
					ilog = '/mnt/sysimage/tmp/post.log'
					post = True
				if(ilog):
					count = len(open(ilog).readlines())
					line = linecache.getline(ilog,count)
					linecache.clearcache()
				if(line and not post and not pre):
					r2 = re.compile("Installing ([^ ]*) \((\d+)/(\d+)\)")
					m2 = r2.search(line)
					if m2:
						newline = "%s (%.2f%%)" % (m2.group(1), 100 * float(m2.group(2)) / float(m2.group(3)))
					else:
						newline = "post"
					line = "installing " + newline
				if(line and post and not pre):
					line = "installing " + line
				if(not line):
					line = "installing prep"
				newSocket.send(line)
				break
#UNCOMMENTOENABLEDEBUGPORT#			if(command[0] == "sh"): #DEBUG purposes only, wide open root priv command here.
#UNCOMMENTOENABLEDEBUGPORT#				newcommand = ""
#UNCOMMENTOENABLEDEBUGPORT#				for i in command[1:]:
#UNCOMMENTOENABLEDEBUGPORT#					newcommand = newcommand + i + " "
#UNCOMMENTOENABLEDEBUGPORT#				output = os.popen(newcommand).read()
#UNCOMMENTOENABLEDEBUGPORT#				newSocket.send(output)
#UNCOMMENTOENABLEDEBUGPORT#				break
			if(command[0] == "screendump"):
				newcommand = "cat /dev/vcs"
				for i in command[1:]:
					newcommand = newcommand + i
				output = os.popen(newcommand).read()
				newSocket.send(output)
				break
				
		newSocket.close()

finally:
	sock.close()
EOF

chmod 755 /tmp/foo.py
chmod 755 /tmp/baz.py

NODESTATUS=

if [ -z "$NODESTATUS" ] || [ "$NODESTATUS" != "0" -a   "$NODESTATUS" != "N"  -a  "$NODESTATUS" != "n" ]; then
   /tmp/baz.py "installstatus installing" &
fi



/tmp/foo.py >/foo.log 2>&1 &

base64decode()
{
    h0="0";  h1="1";  h2="2";  h3="3";  h4="4";  h5="5";  h6="6";  h7="7";
    h8="8";  h9="9"; h10="A"; h11="B"; h12="C"; h13="D"; h14="E"; h15="F";

    while :
    do
        i=0
        while [ "$i" -lt 4 ]
        do
            read -n 1 c || return

            case "${c}" in
            "A") d=0  ;; "B") d=1  ;; "C") d=2  ;; "D") d=3  ;;
            "E") d=4  ;; "F") d=5  ;; "G") d=6  ;; "H") d=7  ;;
            "I") d=8  ;; "J") d=9  ;; "K") d=10 ;; "L") d=11 ;;
            "M") d=12 ;; "N") d=13 ;; "O") d=14 ;; "P") d=15 ;;
            "Q") d=16 ;; "R") d=17 ;; "S") d=18 ;; "T") d=19 ;;
            "U") d=20 ;; "V") d=21 ;; "W") d=22 ;; "X") d=23 ;;
            "Y") d=24 ;; "Z") d=25 ;; "a") d=26 ;; "b") d=27 ;;
            "c") d=28 ;; "d") d=29 ;; "e") d=30 ;; "f") d=31 ;;
            "g") d=32 ;; "h") d=33 ;; "i") d=34 ;; "j") d=35 ;;
            "k") d=36 ;; "l") d=37 ;; "m") d=38 ;; "n") d=39 ;;
            "o") d=40 ;; "p") d=41 ;; "q") d=42 ;; "r") d=43 ;;
            "s") d=44 ;; "t") d=45 ;; "u") d=46 ;; "v") d=47 ;;
            "w") d=48 ;; "x") d=49 ;; "y") d=50 ;; "z") d=51 ;;
            "0") d=52 ;; "1") d=53 ;; "2") d=54 ;; "3") d=55 ;;
            "4") d=56 ;; "5") d=57 ;; "6") d=58 ;; "7") d=59 ;;
            "8") d=60 ;; "9") d=61 ;; "+") d=62 ;; "/") d=63 ;;
            "=") d=0  ;;
            *) continue ;;
            esac

            eval "a${i}=${c}"
            eval "b${i}=${d}"

            i=$(( i + 1 ))
        done

        o0=$(( ((b0 << 2) | (b1 >> 4)) & 0xff ))
        o1=$(( ((b1 << 4) | (b2 >> 2)) & 0xff ))
        o2=$(( ((b2 << 6) | b3) & 0xff ))

        [ "${a2}" == "=" ] &&
            eval "printf \"\\x\${h$(( o0 / 16 ))}\${h$(( o0 % 16
                ))}\"" &&
            return
        [ "${a3}" == "=" ] &&
            eval "printf \"\\x\${h$(( o0 / 16 ))}\${h$(( o0 % 16
                ))}\\x\${h$(( o1 / 16 ))}\${h$(( o1 % 16
                ))}\"" &&
            return
        eval "printf \"\\x\${h$(( o0 / 16 ))}\${h$(( o0 % 16
            ))}\\x\${h$(( o1 / 16 ))}\${h$(( o1 % 16
            ))}\\x\${h$(( o2 / 16 ))}\${h$(( o2 % 16 ))}\""
    done
}

#time to ascertain fstype and PReP/UEFI/legacy
#also, find first available block device (sda or vda likely)
#TODO: pick a likely non-SAN target if possible
shopt -s nullglob

msgutil_r "$MASTER_IP" "info" "Detecting install disk..." "/var/log/xcat/xcat.log" "$log_label"
#
# The getinstdisk script is common for RHEL/SLES/PowerKVM/Ubuntu.
# It will attempt to select the install disk and write the selection to /tmp/xcat.install_disk
#
#!/bin/sh

#-----------------------------------------------------------
#
# Get proper disk to install OS
#
# 1. Check all partitions listed in /proc/partitions, whether
#    there is a disk that had OS installed. If there is, add it to
#    the disk array.
# 2. If there is no disk that had OS installed found
#    in Step 1, then check all disks in
#    /proc/partitions file. Sort them by driver type, then by WWN/PATH
#    select the first one.
# 3. If no disks selected in Steps 1 or 2, then
#    select the default disk: /dev/sda.
#
# Output: Install disk name written to /tmp/xcat.install_disk
#
#-----------------------------------------------------------

install_disk=""
install_disk_file="/tmp/xcat.install_disk"

tmpdir="/tmp/xcat.getinstalldisk"
mkdir -p $tmpdir

has_awk=$(find /usr/* -name "awk")

utolcmd="sed -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/"

tmpfile="$tmpdir/getinstalldisk_"

if [ -z "$install_disk" ]; then

    echo "[get_install_disk]Contents of /proc/partitions:"
    cat /proc/partitions
    echo ""

    # Get all partitions and disks from /proc/partitions file
    if [ -z "$has_awk" ]; then
        entries=$(cat /proc/partitions | sed 's/  */ /g' | cut -d " " -f5 | grep -v "name" | grep -E '^[s|h|v]d|nvme')
    else
        entries=$(awk -F ' '  '{print $4}' /proc/partitions | grep -v "name" | grep -E '^[s|h|v]d|nvme')
    fi

    # Classify entries by DEVTYPE
    for entry in $entries; do
        DEVSIZE=$(udevadm info --attribute-walk --name=$entry|grep \{size\}| sed -e 's/[^"]*"//' -e 's/"//'|tail -n 1)
        if [ -z "$DEVSIZE" -o $DEVSIZE -lt 262144 ]; then
            # ignore small devices, that are likely remote media or similar
            echo "[get_install_disk]    Skipping partition $entry. Size too small: $DEVSIZE"
            continue
        fi

        if [ -z "$has_awk" ]; then
            dev_type=$(udevadm info --query=property --name=/dev/$entry | grep -i "DEVTYPE" | cut -d "=" -f2 | $utolcmd)
        else
            dev_type=$(udevadm info --query=property --name=/dev/$entry | grep -i "DEVTYPE" | awk -F = '{print $2}' | $utolcmd)
        fi

        if [ "$dev_type" == "disk" ]; then
            disks=$disks"$entry "
        elif [ "$dev_type" == "partition" ]; then
            partitions=$partitions"$entry "
        fi
    done

    mount_dir=$tmpdir"/xcat.getinstalldisk.mount"
    mkdir -p $mount_dir;

    disk_array=""
    umount_rc=0

    for partition in $partitions; do
        echo "[get_install_disk]Check the partition $partition."

        if [ -e "$tmpfile${partition%%[0-9]*}" ]; then
            echo "[get_install_disk]    The disk ${partition%%[0-9]*} had OS installed, check next partition."
            continue
        fi

        # Get partition's fs_type
        if [ -z "$has_awk" ]; then
            fs_type=$(udevadm info --query=property --name=/dev/$partition | grep -i "FS_TYPE" | cut -d "=" -f2)
        else
            fs_type=$(udevadm info --query=property --name=/dev/$partition | grep -i "FS_TYPE" | awk -F = '{print $2}')
        fi

        rc=255

        # Mount partition based on fs type, if fs_type is "swap", do not mount it, jump to next partition.
        if [ -z "$fs_type" ]; then
            mount /dev/$partition $mount_dir
            rc=$?
        elif [ "$fs_type" != "swap" ]; then
            mount -t $fs_type /dev/$partition $mount_dir
            rc=$?
        fi

        # Check whether mount successfully
        if [ $rc -eq 0 ]; then
            echo "[get_install_disk]    Partition $partition mount success."

            ker_dir=$mount_dir
            if [ -d "$mount_dir/boot" ]; then
                ker_dir="$mount_dir/boot"
            fi

            # If there is kernel file, add partition's disk into disk_array
            # It seems the kernel file in ubuntu and sles are named like vmlinux, but in RH it is called vmlinuz
            # To check both vmlinux and vmlinuz, use regular expression "vmlinu*" to match them
            for i in $(find $ker_dir -maxdepth 1 -name "vmlinu*"); do
                case $partition in
                    nvme*)
                        # Expected nvme partition format example: nvme0n1p1
                        disk_part=${partition%%p*}
                    ;;
                    *)
                        # Expected sd partition format example: sda1
                        disk_part=${partition%%[0-9]*}
                    ;;
                esac
                touch "$tmpfile$disk_part"
                disk_array=$disk_array"$disk_part "
                echo "[get_install_disk]    The partition $partition has kernel file."
                break
            done

            umount -l $mount_dir || echo "[get_install_disk]    $partition umount failed."
            if [ $? -ne 0 ]; then
                # Preserve a umount failure RC
                umount_rc=$?
            fi
        else
            echo "[get_install_disk]    Partition $partition mount failed or the partition is swap."
        fi
    done

    # If disk_array is not empty, make disks equal disk_array for next step to sort
    if [ "$disk_array" ]; then
        disks=$disk_array
        echo "[get_install_disk]The disks which have kernel:"
        echo "[get_install_disk]    $disks"
        echo ""
    fi

    if [ $umount_rc -eq 0 ]; then
        rmdir $mount_dir;
    else
        # Do not remove $mount_dir if there was a umount failure, as it might wipe out
        # the contents of a still mounted disk
        echo "[get_install_disk]There was a umount failure earlier, not removing $mount_dir"
    fi

    for file in $tmpfile*; do
        rm $file;
    done

    has_wwn=0
    has_path=0
    file_pre=""
    disk_data=""

    # Check disks which had installed OS, or check all disks in /proc/partitions
    for disk in $disks; do
        # Get disk's information: WWN, PATH and DRIVER
        disk_info=$(udevadm info --query=property --name=$disk)
        output_for_wwn=$(IFS= ;echo $disk_info | grep '\<ID_WWN\>' | cut -d "=" -f2)
        disk_wwn=$(echo $output_for_wwn | $utolcmd)
        output_for_path=$(IFS= ;echo $disk_info | grep DEVPATH | cut -d "=" -f2)
        disk_path=$(echo $output_for_path | $utolcmd)
        disk_driver=$(udevadm info --attribute-walk --name=$disk | grep DRIVERS| grep -v '""'| grep -v '"sd"'|
                    \head -n 1| sed -e 's/[^"]*"//' -e 's/"//' | $utolcmd)

        echo "[get_install_disk]The disk $disk information: "
        echo "[get_install_disk]    disk_wwn=$disk_wwn"
        echo "[get_install_disk]    disk_path=$disk_path"
        echo "[get_install_disk]    disk_driver=$disk_driver"

        # Check whether there is WWN, PATH information
        if [ "$disk_wwn" ]; then
            has_wwn=1
            file_pre="wwn"
            disk_data=$disk_wwn
        elif [ $has_wwn -eq 1 ]; then
            echo "[get_install_disk]    The disk $disk has no wwn info."
            echo "[get_install_disk]    There is another disk with wwn info, so don't record this disk."
            continue;
        elif [ "$disk_path" ]; then
            has_path=1
            file_pre="path"
            disk_data=$disk_path
        elif [ $has_path -eq 1 ]; then
            echo "[get_install_disk]    The disk $disk has no wwn or path info."
            echo "[get_install_disk]    There is another disk with path info, so don't record this disk."
            continue;
        else
           file_pre="other"
           disk_data=""
        fi

        # Sort disks by DRIVER type
        case "$disk_driver" in
        "ata_piix"*|"PMC MaxRAID"|"ahci"|"megaraid_sas")
            echo "$disk $disk_data" >> "$tmpfile""$file_pre""firstchoicedisks"
            echo "[get_install_disk]    Add disk: $disk $disk_data into $file_pre firstchoicedisks"
            ;;
        "mptsas"|"mpt2sas"|"mpt3sas")
            echo "$disk $disk_data" >> "$tmpfile""$file_pre""secondchoicedisks"
            echo "[get_install_disk]    Add disk: $disk $disk_data into $file_pre secondchoicedisks"
            ;;
        *)
            echo "$disk $disk_data" >> "$tmpfile""$file_pre""thirdchoicedisks"
            echo "[get_install_disk]    Add disk: $disk $disk_data into $file_pre thirdchoicedisks"
            ;;
        esac
    done

    for seq in first second third; do
        if [ -s $tmpfile$file_pre${seq}choicedisks ]; then
            install_file="$tmpfile$file_pre${seq}choicedisks"
            break
        fi
    done

    if [ "$install_file" ] && [ -s $install_file ]; then
        install_disk=/dev/$(cat $install_file | grep -v "^$" | sort -k 2 -b | cut -d " " -f1 | head -n 1)
        echo "[get_install_disk]The install_disk is $install_disk by sorting $file_pre and DRIVER."
    fi

    for file in $tmpfile*; do
        rm $file;
    done
fi
rm -rf $tmpdir;

# Cannot find proper disk for OS install, select the default one "/dev/sda"
if [ -z "$install_disk" ]; then
    install_disk="/dev/sda"
    echo "[get_install_disk]Choosing default install_disk $install_disk."
fi

# Output the result to $install_disk_file
echo $install_disk > $install_disk_file
if [ -e "/tmp/xcat.install_disk" ]; then
    instdisk=`cat /tmp/xcat.install_disk`
fi

modprobe ext4 >& /dev/null
modprobe ext4dev >& /dev/null
if grep ext4dev /proc/filesystems > /dev/null; then
	FSTYPE=ext3
elif grep ext4 /proc/filesystems > /dev/null; then
	FSTYPE=ext4
else
	FSTYPE=ext3
fi
BOOTFSTYPE=ext4
EFIFSTYPE=vfat

if uname -r|grep -q '^3.*el7'; then
    BOOTFSTYPE=xfs
    FSTYPE=xfs
    EFIFSTYPE=efi
fi

#remove any exiting "xcatvg" VG to avoid fatal error
vgs > /tmp/vgs 2>&1
vgchange -a n xcatvg
vgremove -f xcatvg

msgutil_r "$MASTER_IP" "info" "Found $instdisk, generate partition file..." "/var/log/xcat/xcat.log" "$log_label"
echo "ignoredisk --only-use=$instdisk" >> /tmp/partitionfile
if [ `uname -m` = "ppc64" -o `uname -m` = "ppc64le" ]; then
	echo 'part None --fstype "PPC PReP Boot" --ondisk '$instdisk' --size 8' >> /tmp/partitionfile
fi
if [ -d /sys/firmware/efi ]; then
    echo 'part /boot/efi --size 50 --ondisk '$instdisk' --fstype '$EFIFSTYPE >> /tmp/partitionfile
fi

#TODO: ondisk detection, /dev/disk/by-id/edd-int13_dev80 for legacy maybe, and no idea about efi.  at least maybe blacklist SAN if mptsas/mpt2sas/megaraid_sas seen...
echo "part /boot --size 512 --fstype $BOOTFSTYPE --ondisk $instdisk" >> /tmp/partitionfile
echo "part swap --recommended --ondisk $instdisk" >> /tmp/partitionfile
echo "part pv.01 --size 1 --grow --ondisk $instdisk" >> /tmp/partitionfile
echo "volgroup xcatvg pv.01" >> /tmp/partitionfile
echo "logvol / --vgname=xcatvg --name=root --size 1 --grow --fstype $FSTYPE" >> /tmp/partitionfile

#specify "bootloader" configuration in "/tmp/partitionfile" if there is no user customized partition file
BOOTLOADER="bootloader "

#Specifies which drive the boot loader should be written to
#and therefore which drive the computer will boot from.
[ -n "$instdisk" ] && BOOTLOADER=$BOOTLOADER" --boot-drive=$(basename $instdisk)"

echo "$BOOTLOADER" >> /tmp/partitionfile
	
#XCA_PARTITION_SCRIPT#

#specify the kernel options which will be persistent after installation
if [ -n "" ];then
    #append the persistent kernel options to the lines including "bootloader --append"
    sed -i -e /bootloader/s#\'#\"#g -e '/bootloader/s/--append=\([^"]\S*[^"]\)/--append="\1"/g' -e '/bootloader/s/--append="\(.*\)"/--append="\1 "/g' /tmp/partitionfile
    #append the persistent kernel options to the lines including "bootloader" without "--append"
    sed -i -e '/bootloader/{/append=/!s/$/& --append="" /}' /tmp/partitionfile
    #append the persistent kernel options to /tmp/partitionfile if it does not include "bootloader"
    grep bootloader /tmp/partitionfile >/dev/null 2>&1|| echo -e "bootloader --append=\"\"" >>/tmp/partitionfile
fi

#save the content of /tmp/partitionfile in /var/log/xcat/xcat.log
#so that we can inspect the partition scheme after installation
echo "=================The Partition Scheme================"
cat /tmp/partitionfile
echo "====================================================="

# The following code is to generate the repository for the installation
msgutil_r "$MASTER_IP" "info" "Generate the repository for the installation" "/var/log/xcat/xcat.log" "$log_label"
cat /proc/cmdline

NEXTSERVER=`cat /proc/cmdline | grep http | head -n 1`
NEXTSERVER=${NEXTSERVER#*http://}
NEXTSERVER=${NEXTSERVER%%:*}

export nextserver=$NEXTSERVER
echo 'url --url http://'$nextserver':80//install/centos7.9/x86_64' >> /tmp/repos

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set +x
fi
} &>>/tmp/pre-install.log
%end
%post
mkdir -p /var/log/xcat/
{
cat >> /var/log/xcat/xcat.log << "EOF"
%include /tmp/pre-install.log
EOF
echo "Running Kickstart Post-Installation script..."
#
# Run xCAT post install
#
export MASTER_IP="192.168.122.1"
export MASTER="192.168.122.1"
export NODESTATUS=""
export XCATIPORT=3002
export INSTALLDIR=/install
export TFTPDIR=/tftpboot
export XCATDEBUGMODE=""
export HTTPPORT=""

declare -F msgutil_r &>/dev/null  || function msgutil_r {
   local logserver=$1
   local msgtype=$2
   local msgstr=$3
   local logfile=$4
   local logtag=$5

   if [ -z "$msgtype"  ]; then
      msgtype="debug"
   fi

   if [ -z "$logtag" ]; then
      logtag="xcat"
   fi

   if [ -n "$logserver" ];then
      logger -n $logserver -t $logtag -p local4.$msgtype "$msgstr"
      if [ "$?" != "0" ];then
         exec 3<>/dev/udp/$logserver/514 >/dev/null;logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&3
         if [ "$?" != "0" ];then
            logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&1|nc $logserver 514 >/dev/null 2>&1
            if [ "$?" != "0" ];then
               logger -t $logtag -p local4.$msgtype "$msgstr"
            fi
         fi
      fi
   else
       logger -t $logtag -p local4.$msgtype "$msgstr"
   fi
   if [ -n "$logfile"  ]; then
      local logdir="$(dirname $logfile)"
      if [ ! -d "$logdir" ]; then
         mkdir -p "$logdir"
         touch "$logfile"
      fi

      echo "$(date) [$msgtype]: $logtag: $msgstr" >> $logfile
   fi

}

declare -F msgutil &>/dev/null  || function msgutil {
    msgutil_r "" "$@"
}


if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set -x
fi

if [ -z "$XCATIPORT" ]; then
    XCATIPORT="3002"
fi
if [ -z "$INSTALLDIR" ]; then
    INSTALLDIR="/install"
fi
if [ -z "$TFTPDIR" ]; then
    TFTPDIR="/tftpboot"
fi
if [[ $TFTPDIR != /* ]]; then
    TFTPDIR="/"$TFTPDIR
fi
if [ -z "$HTTPPORT" ]; then
    HTTPPORT="80"
fi

NODESTATUS=$(echo "$NODESTATUS"| tr -d \'\"| tr A-Z a-z)

(cat  << 'EOF'
#!/usr/bin/awk -f
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html

BEGIN {
    xcatdhost = ARGV[1]
    xcatdport = ARGV[2]
    flag = ARGV[3]

    if (!flag) flag = "next"

    ns = "/inet/tcp/0/" xcatdhost "/" xcatdport

    loop = 0
    while(1) {
        if((ns |& getline) > 0)
            print $0 | "logger -t xcat -p local4.info"
        else {
            print "Retrying flag update" | "logger -t xcat -p local4.info"
            print "updateflag.awk: Retrying flag update" >> "/var/log/xcat/xcat.log"
            close(ns)
            system("sleep 10")
            loop = loop + 1
        }

        if($0 == "ready")
            print flag |& ns
        if($0 == "done")
            break
        if(loop > 10) {
            print "flag update failed" | "logger -t xcat -p local4.info"
            print "updateflag.awk: flag update failed" >> "/var/log/xcat/xcat.log"
            break
        }
    }

    close(ns)

    exit 0
}

EOF
) >/tmp/updateflag

chmod 0755 /tmp/updateflag

cd /tmp
log_label="xcat.deployment"
msgutil_r "$MASTER_IP" "info" "Executing post.xcat to prepare for firstbooting ..." "/var/log/xcat/xcat.log" "$log_label"

RAND=$(perl -e 'print int(rand(50)). "\n"')
if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
   msgutil_r "$MASTER_IP" "debug" "sleep $RAND" "/var/log/xcat/xcat.log" "$log_label"
fi
sleep $RAND

# Stop if no openssl to help the next bit
if [ ! -x /usr/bin/openssl ]; then
    msgutil_r "$MASTER_IP" "error" "/usr/bin/openssl does not exist, halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
fi

#save to /opt/xcat/xcatinfo file
if [ ! -f /opt/xcat/xcatinfo ]; then
    mkdir -p /opt/xcat
    touch /opt/xcat/xcatinfo
fi

grep 'XCATSERVER' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/XCATSERVER=.*/XCATSERVER=$MASTER_IP/" /opt/xcat/xcatinfo
else
    echo "XCATSERVER=$MASTER_IP" >> /opt/xcat/xcatinfo
fi

grep 'INSTALLDIR' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/INSTALLDIR=.*/INSTALLDIR=$INSTALLDIR/" /opt/xcat/xcatinfo
else
    echo "INSTALLDIR=$INSTALLDIR" >> /opt/xcat/xcatinfo
fi

grep 'HTTPPORT' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/HTTPPORT=.*/HTTPPORT=$HTTPPORT/" /opt/xcat/xcatinfo
else
    echo "HTTPPORT=$HTTPPORT" >> /opt/xcat/xcatinfo
fi

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    msgutil_r "$MASTER_IP" "debug" "/opt/xcat/xcatinfo generated" "/var/log/xcat/xcat.log" "$log_label"
fi

# download the postscripts
msgutil_r "$MASTER_IP" "info" "trying to download postscripts from $MASTER_IP..." "/var/log/xcat/xcat.log" "$log_label"

# Stop if no wget to help the next bit
if [ ! -x /usr/bin/wget ]; then
    msgutil_r "$MASTER_IP" "error" "/usr/bin/wget does not exist, halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
fi

wget -l inf -N -r --waitretry=10 --random-wait --retry-connrefused  -e robots=off -nH --cut-dirs=2 --reject "index.html*" --no-parent -t 20 -T 60 http://${MASTER_IP}:${HTTPPORT}${INSTALLDIR}/postscripts/ -P /xcatpost 2> /tmp/wget.log
if [ "$?" != "0" ]; then
    msgutil_r "$MASTER_IP" "error" "failed to download postscripts from http://$MASTER_IP$INSTALLDIR/postscripts/,check /tmp/wget.log on the node,  halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
fi
chmod -R +x `find /xcatpost/ -maxdepth 1 -print | grep -E -v '^(/xcatpost/|/xcatpost/_xcat|/xcatpost/_ssh|/xcatpost/ca|/xcatpost/hostkeys)$'`
msgutil_r "$MASTER_IP" "info" "postscripts downloaded successfully" "/var/log/xcat/xcat.log" "$log_label"

# get the precreated mypostscript file
if [ -x /xcatpost/mypostscript ]; then
    rm -rf /xcatpost/mypostscript
fi
export NODE=ma2

msgutil_r "$MASTER_IP" "info" "trying to get mypostscript from $MASTER_IP..." "/var/log/xcat/xcat.log" "$log_label"

wget -N --waitretry=10 --random-wait --retry-connrefused -t 20 -T 60 http://${MASTER_IP}:${HTTPPORT}${TFTPDIR}/mypostscripts/mypostscript.$NODE  -P /xcatpost 2> /tmp/wget.log
if [ "$?" = "0" ]; then
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "precreated mypostscript downloaded successfully" "/var/log/xcat/xcat.log" "$log_label"
    fi
    mv /xcatpost/mypostscript.$NODE /xcatpost/mypostscript
    chmod 700 /xcatpost/mypostscript
fi

USEOPENSSLFORXCAT=1 #Though this is the only method going forward, flag to allow backward compatibility with 2.2 generated netboot images
export USEOPENSSLFORXCAT
XCATSERVER=$MASTER_IP:3001
export XCATSERVER

# If mypostscript doesn't exist, we will get it through getpostscript.awk
if [ ! -x /xcatpost/mypostscript ]; then
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "no pre-generated mypostscript.<nodename>, trying to get it with getpostscript.awk..." "/var/log/xcat/xcat.log" "$log_label"
    fi

    # To support the postscripts in the subdirectories under /install/postscripts
    # chmod +x /xcatpost/*
    # Stop if no getpostscript.awk to help the next bit
    if [ ! -x /xcatpost/getpostscript.awk ]; then
        msgutil_r "$MASTER_IP" "error" "/xcatpost/getpostscript.awk does not exist, halt ..." "/var/log/xcat/xcat.log" "$log_label"
        /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
        sleep 36500d
    fi
    /xcatpost/getpostscript.awk |egrep '<data>'|sed -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" > /xcatpost/mypostscript

    MYCONT=`grep ^MASTER= /xcatpost/mypostscript`
    RETRY=0
    while [ -z "$MYCONT" ]; do
        RETRY=$(($RETRY+1))
        if [ $RETRY -eq "10" ]; then
            break
        fi

        let SLI=$RANDOM%10+10
        sleep $SLI
        /xcatpost/getpostscript.awk |egrep '<data>'|sed -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" > /xcatpost/mypostscript

        MYCONT=`grep ^MASTER= /xcatpost/mypostscript`
    done
fi

TMP=`sed "/^#\s*postscripts-start-here/,/^#\s*postscripts-end-here/ s/\(.*\)/run_ps postscript \1/;s/run_ps postscript\s*#/#/;s/run_ps postscript\s*$//" /xcatpost/mypostscript`
echo "$TMP" > /xcatpost/mypostscript
TMP=`sed "/^#\s*postbootscripts-start-here/,/^#\s*postbootscripts-end-here/ s/\(.*\)/run_ps postbootscript \1/;s/run_ps postbootscript\s*#/#/;s/run_ps postbootscript\s*$//" /xcatpost/mypostscript`

cd /xcatpost
#gunzip xcatpost.tar.gz
#tar -xvf xcatpost.tar
#/xcatpost/ma2
export PATH=$PATH:/xcatpost

# use the run_ps subroutine to run the postscripts

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    echo "set -x" > /xcatpost/mypostscript
else
    cat /dev/null > /xcatpost/mypostscript
fi

echo "

. /xcatpost/xcatlib.sh

# global value to store the running status of the postbootscripts,the value is non-zero if one postbootscript failed
return_value=0

# subroutine used to run postscripts
# \$1 argument is the script type
# rest argument is the script name and arguments
run_ps () {
    local ret_local=0
    mkdir -p "\"/var/log/xcat\""
    # On some Linux distro, the rsyslogd daemon write log files with permision
    # other than root:root. And in some case, the directory /var/log/xcat was
    # created by xCAT, and had root:root ownership. In this way, rsyslogd
    # did not have enough permission to write to log files under this directory.
    # As a dirty hack, change the ownership of directory /var/log/xcat to the
    # same ownership of directory /var/log.
    chown `ls -ld /var/log | awk '{ print \$3\":\"\$4 }'` "\"/var/log/xcat\""
    local logfile=\"/var/log/xcat/xcat.log\"
    local scriptype=\$1
    shift;

    if [ -z \"\$scriptype\" ]; then
        scriptype=\"postscript\"
    fi
    log_label=\"xcat.deployment.\"\$scriptype
    export LOGLABEL=\$log_label
    if [ -f \$1 ]; then
        msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype start..: \$1\"" \"\$logfile\" \"\$log_label\"
        if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
            local compt=\$(file \$1)
            local reg=\"shell script\"
            if [[ \"\$compt\" =~ \$reg ]]; then
                bash -x ./\$@ 2>&1
                ret_local=\$?
            else
                ./\$@ 2>&1 | logger -t \$log_label -p debug
                ret_local=\${PIPESTATUS[0]}
            fi
        else
            ./\$@ 2>&1
            ret_local=\${PIPESTATUS[0]}
        fi

        if [ \"\$ret_local\" -ne \"0\" ]; then
            return_value=\$ret_local
        fi
        msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype end...: \$1 return with \$ret_local\"" \"\$logfile\" \"\$log_label\"
    else
        msgutil_r \"\$MASTER_IP\" \"error\" "\"\$scriptype \$1 does NOT exist.\"" \"\$logfile\" \"\$log_label\"
        return_value=-1
    fi


    return 0
}
# subroutine end

" >> /xcatpost/mypostscript
echo "$TMP" >> /xcatpost/mypostscript

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    echo "set +x" >> /xcatpost/mypostscript
fi

chmod +x /xcatpost/mypostscript
if [ ! -x /xcatpost/mypostscript ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate mypostscript file, halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "generate mypostscript file successfully" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


#save the postboot scripts to /xcatpost/mypostscript.post
TMP=`sed "/^#\s*postscripts-start-here/,/^#\s*postscripts-end-here/ d" /xcatpost/mypostscript`
echo "$TMP" > /xcatpost/mypostscript.post
chmod 755 /xcatpost/mypostscript.post

if [ ! -x /xcatpost/mypostscript.post ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate /xcatpost/mypostscript.post" "/var/log/xcat/xcat.log" "$log_label"
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "generate mypostscript.post file successfully" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


export OSVER=centos7.9
#create the post init service as a hook to run PS and PBS, as well as status updating
hassystemd=0
systemctl --version 2>/dev/null
if [ $? -eq 0 ]; then
    hassystemd=1
fi

if [ $hassystemd -eq 1 ] ; then
    if [[ $OSVER =~ sle && $OSVER != sles11* ]]; then
        cat >/etc/systemd/system/xcatpostinit1.service <<'EOF'
[Unit]
Description=xcat service on compute node, the framework to run postbootscript during OS provision
After=network.target rsyslog.service YaST2-Firstboot.service

[Service]
Type=oneshot
ExecStart=/opt/xcat/xcatpostinit1 start
ExecStop=/opt/xcat/xcatpostinit1 stop
StandardOutput=null
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
        cat >/opt/xcat/xcatpostinit1.service.sles <<'EOF'
[Unit]
Description=xcat service on compute node, the framework to run postbootscript and update node status
After=network.target rsyslog.service

[Service]
Type=oneshot
ExecStart=/opt/xcat/xcatpostinit1 start
ExecStop=/opt/xcat/xcatpostinit1 stop
StandardOutput=null
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    else
        cat >/etc/systemd/system/xcatpostinit1.service <<'EOF'
[Unit]
Description=xcat service on compute node, the framework to run postbootscript and update node status
After=network.target rsyslog.service

[Service]
Type=oneshot
ExecStart=/opt/xcat/xcatpostinit1 start
ExecStop=/opt/xcat/xcatpostinit1 stop
StandardOutput=null
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    fi
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "/etc/systemd/system/xcatpostinit1.service generated" "/var/log/xcat/xcat.log" "$log_label"
    fi

    ln -s /etc/systemd/system/xcatpostinit1.service /etc/systemd/system/multi-user.target.wants/xcatpostinit1.service

    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "xcatpostinit1.service enabled" "/var/log/xcat/xcat.log" "$log_label"
    fi
    cat >/opt/xcat/xcatpostinit1 << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
# chkconfig: 345 84 59
# description: the hook for systemd service unit to run PB and report node status on diskful node
# processname: xcatpostinit1

### BEGIN INIT INFO
# Provides:             xcatpostinit1
# Required-Start:       $network $syslog
# Should-Start:
# Required-Stop:        $network $syslog
# Should-Stop:
# Default-Start:        3 4 5
# Default-Stop:         0 1 2 6
# Short-Description:    hook to run xcat PBS and report node status
# Description:
### END INIT INFO

# Source function library.
if [ -x /etc/rc.d/init.d/functions ]; then
  . /etc/rc.d/init.d/functions
fi

[ -f /opt/xcat/xcatinfo ] && XCATSERVER=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\" `
[ -f /xcatpost/mypostscript ] && NODESTATUS=`grep 'NODESTATUS=' /xcatpost/mypostscript |awk -F = '{print $2}'|tr -d \'\" | tr A-Z a-z `
[ -z "$NODESTATUS" ] && NODESTATUS="1"
[ -f /xcatpost/mypostscript ] && RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z `

case $1 in
stop)
  [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus powering-off"
  ;;
start)
  # check for the REBOOT specified in xcatinfo to run post boot scripts on reboot
  if [ -f /opt/xcat/xcatinfo ]; then
    REBOOT=`grep 'REBOOT' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\"`
  fi
  # if the xcatdsklspost file exists and this is a reboot - run xcatdsklspost with a mode of 6
  if [ "$REBOOT" = "TRUE" -a -r /opt/xcat/xcatdsklspost ] && [[ "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
      [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
      # xcatdsklspost will set the status to 'booted' or 'failed'
      /opt/xcat/xcatdsklspost 6
  elif [ "$REBOOT" = "TRUE" ] && [[ "$NODESTATUS" =~  ^(1|yes|y)$ ]]; then
      /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus booted"
  else
    [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
    # run /opt/xcat/xcatinstallpost, it will set the status to 'booted' or 'failed'
    if [ -r /opt/xcat/xcatinstallpost ]; then
      /opt/xcat/xcatinstallpost
    fi
    if [ -f /opt/xcat/xcatpostinit1.service.sles ]; then
        rm -rf /etc/systemd/system/xcatpostinit1.service
        mv /opt/xcat/xcatpostinit1.service.sles /etc/systemd/system/xcatpostinit1.service
    fi
  fi

  ;;
esac
EOF
    chmod 755 /opt/xcat/xcatpostinit1
else
    cat >/etc/init.d/xcatpostinit1 << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
# chkconfig: 345 84 59
# description: the hook for systemd service unit to run PB and report node status on diskful node
# processname: xcatpostinit1

### BEGIN INIT INFO
# Provides:             xcatpostinit1
# Required-Start:       $network $syslog
# Should-Start:
# Required-Stop:        $network $syslog
# Should-Stop:
# Default-Start:        3 4 5
# Default-Stop:         0 1 2 6
# Short-Description:    hook to run xcat PBS and report node status
# Description:
### END INIT INFO

# Source function library.
if [ -x /etc/rc.d/init.d/functions ]; then
  . /etc/rc.d/init.d/functions
fi

[ -f /opt/xcat/xcatinfo ] && XCATSERVER=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\" `
[ -f /xcatpost/mypostscript ] && NODESTATUS=`grep 'NODESTATUS=' /xcatpost/mypostscript |awk -F = '{print $2}'|tr -d \'\" | tr A-Z a-z `
[ -z "$NODESTATUS" ] && NODESTATUS="1"
[ -f /xcatpost/mypostscript ] && RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z `

case $1 in
stop)
  [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus powering-off"
  ;;
start)
  # check for the REBOOT specified in xcatinfo to run post boot scripts on reboot
  if [ -f /opt/xcat/xcatinfo ]; then
    REBOOT=`grep 'REBOOT' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\"`
  fi
  # if the xcatdsklspost file exists and this is a reboot - run xcatdsklspost with a mode of 6
  if [ "$REBOOT" = "TRUE" -a -r /opt/xcat/xcatdsklspost ] && [[ "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
      [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
      # xcatdsklspost will set the status to 'booted' or 'failed'
      /opt/xcat/xcatdsklspost 6
  elif [ "$REBOOT" = "TRUE" ] && [[ "$NODESTATUS" =~  ^(1|yes|y)$ ]]; then
      /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus booted"
  else
    [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
    # run /opt/xcat/xcatinstallpost, it will set the status to 'booted' or 'failed'
    if [ -r /opt/xcat/xcatinstallpost ]; then
      /opt/xcat/xcatinstallpost
    fi
    if [ -f /opt/xcat/xcatpostinit1.service.sles ]; then
        rm -rf /etc/systemd/system/xcatpostinit1.service
        mv /opt/xcat/xcatpostinit1.service.sles /etc/systemd/system/xcatpostinit1.service
    fi
  fi

  ;;
esac
EOF
    chmod 755 /etc/init.d/xcatpostinit1

    if [ ! -x /etc/init.d/xcatpostinit1 ]; then
        msgutil_r "$MASTER_IP" "error" "failed to generate /etc/init.d/xcatpostinit1" "/var/log/xcat/xcat.log" "$log_label"
    else
        if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r "$MASTER_IP" "debug" "/etc/init.d/xcatpostinit1 generated" "/var/log/xcat/xcat.log" "$log_label"
        fi
    fi

    if [[ $OSVER == ubuntu* ]]; then
        ln -s /etc/init.d/xcatpostinit1 /etc/rc2.d/S84xcatpostinit1
    else
        ln -s /etc/init.d/xcatpostinit1 /etc/rc.d/rc3.d/S84xcatpostinit1
        ln -s /etc/init.d/xcatpostinit1 /etc/rc.d/rc4.d/S84xcatpostinit1
        ln -s /etc/init.d/xcatpostinit1 /etc/rc.d/rc5.d/S84xcatpostinit1
    fi

    if [[ $OSVER == ubuntu* ]]; then
        update-rc.d xcatpostinit1 defaults
    else
        if [[ $OSVER == sle* ]]; then
            if [[ $OSVER == sles10* ]]; then
                /sbin/insserv xcatpostinit1
            else
                /sbin/insserv -p /etc/init.d xcatpostinit1
            fi
        fi
        #chkconfig --add xcatpostinit1
        chkconfig xcatpostinit1 on
        if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r "$MASTER_IP" "debug" "service xcatpostinit1 enabled" "/var/log/xcat/xcat.log" "$log_label"
        fi
    fi
fi

#create the xcatinstallpost
mkdir -p /opt/xcat
cat >/opt/xcat/xcatinstallpost << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
#################################################################
#
#   xCAT script for running postboot scripts for full install case.
#################################################################

. /xcatpost/xcatlib.sh
log_label="xcat.deployment"
if [ -f /xcatpost/mypostscript.post ]; then
    XCATDEBUGMODE=`grep 'XCATDEBUGMODE=' /xcatpost/mypostscript.post |cut -d= -f2 | tr -d \'\" | tr A-Z a-z `
    MASTER_IP=`grep '^MASTER_IP=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    OSVER=`grep '^OSVER=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    NODE=`grep '^NODE=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    IMAGE=`grep '^PROVMETHOD=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
fi


if [ ! `uname` = Linux ]; then
   msgutil_r "$MASTER_IP" "error" "The OS is not Linux" "/var/log/xcat/xcat.log" "$log_label"
   exit
fi
SLI=$(awk 'BEGIN{srand(); printf("%d\n",rand()*10)}')
sleep $SLI

XCATINFOFILE=/opt/xcat/xcatinfo
MACADDR=`grep MACADDRESS= /xcatpost/mypostscript.post | awk -F = '{ print $2 }'| sed "s/\'//g"`
INSTALLNIC=`ip -o link | grep -i "$MACADDR" | awk '{ print $2 }' | sed "s/://"`


# the network between the node and MASTER might be not well configured and activated when running the PBS sometimes
# need to make sure...
RETRY=0
while true; do
    #check whether the network access between MN/CN and the node is ready
    ping $MASTER_IP -c 1 >/dev/null && break

    RETRY=$[ $RETRY + 1 ]

    if [ $RETRY -eq 90 ];then
       #timeout, complain and exit
       msgutil_r "$MASTER_IP" "error" "the network between the node and $MASTER_IP is not ready, please check[retry=$RETRY]..." "/var/log/xcat/xcat.log" "$log_label"
       exit 1
    fi

    #sleep sometime before the next scan
    sleep 2
done


cd /xcatpost;
PATH=/xcatpost:$PATH
export PATH
# To support the postscripts in the subdirectories under /install/postscripts
#chmod +x /xcatpost/*;
chmod -R +x `find /xcatpost/ -maxdepth 1 -print | grep -E -v '^(/xcatpost/|/xcatpost/_xcat|/xcatpost/_ssh|/xcatpost/ca|/xcatpost/hostkeys)$'`

POST_IN_DIR="/xcatpost"

if [ -x /usr/bin/openssl ]; then
     SIP=`grep "^MASTER=" ${POST_IN_DIR}/mypostscript.post  |cut -d= -f2`
     XCATSERVER="$SIP:3001"
     export XCATSERVER
     USEOPENSSLFORXCAT=1 #Though this is the only method going forward, flag to allow backward compatibility with 2.2 generated netboot images
     export USEOPENSSLFORXCAT
fi

#  Regardless of where mypostscript.post was found, modify and run it in /xcatpost.

DHCP_TMP=`sed 's/\(DHCPINTERFACES=\)\(.*\)$/\1"\2"/' /xcatpost/mypostscript.post`
echo "$DHCP_TMP" > /xcatpost/mypostscript.post

#mark that the first reboot after installation is finished
grep 'REBOOT' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/REBOOT=.*/REBOOT=TRUE/" /opt/xcat/xcatinfo
else
    echo "REBOOT=TRUE" >> /opt/xcat/xcatinfo
fi

#add node name to xcatinfo
grep 'NODE' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/NODE=.*/NODE=$NODE/" /opt/xcat/xcatinfo
else
    echo "NODE=$NODE" >> /opt/xcat/xcatinfo
fi

#add image name to xcatinfo
grep 'IMAGENAME' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/IMAGENAME=.*/IMAGENAME=$IMAGE/" /opt/xcat/xcatinfo
else
    echo "IMAGENAME=$IMAGE" >> /opt/xcat/xcatinfo
fi

# Store the SERVICEGROUP into the xcatinfo file for statful installation
sn_group=`grep '^SERVICEGROUP' /xcatpost/mypostscript |cut -d= -f2 | tr -d \'\"`
if [ "x" != "x$sn_group" ]; then
  # Change or add SERVICEGROUP line if service node pool defined.
  grep 'SERVICEGROUP=' $XCATINFOFILE > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    sed -i "s/SERVICEGROUP=.*/SERVICEGROUP=$sn_group/" $XCATINFOFILE
  else
    echo "SERVICEGROUP=$sn_group" >> $XCATINFOFILE
  fi
else
  # Remove SERVICEGROUP line if no service node pool defined.
  sed -i "/SERVICEGROUP=.*/d" $XCATINFOFILE
fi

[ -f /xcatpost/mypostscript ] && NODESTATUS=`grep 'NODESTATUS=' /xcatpost/mypostscript |awk -F = '{print $2}'|tr -d \'\" | tr A-Z a-z `
[ -z "$NODESTATUS" ] && NODESTATUS="1"

CNS=$NODESTATUS
if [ -z "$CNS" ] || [[ "$CNS" =~ ^(1|yes|y)$ ]]; then
#update the node status during the postbootscript running
#TMP=`sed "/postbootscripts-start-here/ i\updateflag.awk \\$MASTER 3002 \\"installstatus configuring\\"" /xcatpost/mypostscript.post`
#echo "$TMP"> /xcatpost/mypostscript.post

echo "

[ -f /opt/xcat/xcatinfo ] && grep 'POSTSCRIPTS_RC=1' /opt/xcat/xcatinfo >/dev/null 2>&1 && return_value=1


if [ \"\$return_value\" -eq \"0\" ]; then
    if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
        msgutil_r \"\$MASTER_IP\" \"debug\" \"node booted, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    fi
    updateflag.awk \$MASTER 3002 \"installstatus booted\"
    msgutil_r \$MASTER_IP \"info\" \"provision completed.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
else
    if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
        msgutil_r \"\$MASTER_IP\" \"debug\" \"node boot failed, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    fi
    updateflag.awk \$MASTER 3002 \"installstatus failed\"
    msgutil_r \$MASTER_IP \"error\" \"provision completed with error.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
fi
" >> /xcatpost/mypostscript.post
fi


chmod +x /xcatpost/mypostscript.post
if [ -x /xcatpost/mypostscript.post ];then
   msgutil_r "$MASTER_IP" "info" "Running /xcatpost/mypostscript.post" "/var/log/xcat/xcat.log" "$log_label"
   /xcatpost/mypostscript.post
   msgutil_r "$MASTER_IP" "info" "/xcatpost/mypostscript.post return" "/var/log/xcat/xcat.log" "$log_label"
   msgutil_r "$MASTER_IP" "info" "=============deployment ending====================" "/var/log/xcat/xcat.log" "$log_label"
fi

if [ -f /xcatpost/mypostscript.post ]; then
    RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /xcatpost/mypostscript.post |cut -d= -f2 | tr -d \'\" | tr A-Z a-z`
fi

if [[ $OSVER == ubuntu* ]]; then
    if [[ ! "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
        update-rc.d -f xcatpostinit1 remove
    fi
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "update-rc.d -f xcatpostinit1 remove" "/var/log/xcat/xcat.log" "xcat.xcatinstallpost"
    fi
else
    if [[ ! "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]] && [[ ! "$NODESTATUS" =~ ^(1|yes|y)$ ]]; then
        chkconfig xcatpostinit1 off
        if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r "$MASTER_IP" "debug" "service xcatpostinit1 disabled" "/var/log/xcat/xcat.log" "xcat.xcatinstallpost"
        fi
    fi

fi

EOF
chmod 755 /opt/xcat/xcatinstallpost

if [ ! -x /opt/xcat/xcatinstallpost ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate /opt/xcat/xcatinstallpost" "/var/log/xcat/xcat.log" "$log_label"
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "/opt/xcat/xcatinstallpost generated" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


#create the dskls post
cat >/opt/xcat/xcatdsklspost << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
#####################################################
#
#   Generic xCAT post script for diskless nodes
#   The syntax of this script:
#      xcatdsklspost {mode} {-m|-M} [postscripts] --tftp /tftpboot --installdir /install --nfsv4 no -c -V
#   This script is called in the following different places:
#      updatenode -P ... --> xcatdsklspost 1 -m/-M ...
#      updatenode -S --> xcatdsklspost 2 -m/-M otherpkgs
#      moncfg rmcmon --> xcatdsklspost 3 configrmcnodes
#      node deployment  --> xcatdsklspost
#      statelite mode   --> xcatdsklspost 4
#      update security  --> xcatdsklspost 5 -m/-M ...
#      node reboot - xcatpostinit1  --> xcatdsklspost 6
# This script has a debug mode,  if XCATDEBUG env variable is set, then
#   /xcatpost becomes /xcatpost.<nodename>.  This allow running multiple
#   instances of the script to simulate many node on one physical node
#
#####################################################

[ -f "/xcatpost/xcatlib.sh" ] &&  . /xcatpost/xcatlib.sh

if [ -f /xcatpost/mypostscript.post ]; then
    XCATDEBUGMODE=`grep 'XCATDEBUGMODE=' /xcatpost/mypostscript.post | cut -d= -f2 | tr -d \'\" | tr A-Z a-z`
    MASTER_IP=`grep '^MASTER_IP=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    NODE=`grep '^NODE=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
else
    for param in `cat /proc/cmdline`; do
            key=`echo $param|awk -F= '{print $1}'`
            if [ "$key" = "xcatdebugmode" ]; then
                    XCATDEBUGMODE=`echo $param|awk -F= '{print $2}'| tr -d \'\" | tr A-Z a-z`
            fi

            if [ "$key" = "LOGSERVER" ]; then
                    MASTER_IP=`echo $param|awk -F= '{print $2}'`
            fi
    done
fi

XCATINFOFILE=/opt/xcat/xcatinfo

#echolog: process message log and echo in xcatdsklspost
#arguments:
#          msgtype: message type, valid values:debug,info,warning,err
#          msgstr : the string of message
#description:
#          echo messages only when ($msgtype != debug) or ($msgtype = debug && $VERBOSE = 1)
#          log "debug" messages only when (site.xcatdebugmode=1),log all messages with other types
#          append the "debug" messages to "/var/log/xcat/xcat.log" when (site.xcatdebugmode=1)
#          append all the other type messages  to "/var/log/xcat/xcat.log"
echolog()
{
   local msgtype=$1
   local msgstr=$2
   local ismsgutil_r=1

   #if msgutil_r is not defined, when no /xcatpost directory exists on the node running this script
   #write the message to local log file as a simplified function
   type -t msgutil_r >/dev/null || ismsgutil_r=0
   [ "$ismsgutil_r" = "0" ]  && msgutil_r () {
                                    echo "$(date) [$2]: $3" >> $4
                                }


   if [ "$msgtype" = "debug"  ];then
      if [ "$VERBOSE" = "1"  ]; then
         echo "$msgstr"
      fi
      if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r  "$MASTER_IP" "$msgtype" "$msgstr" "/var/log/xcat/xcat.log" "$log_label"
      fi
   else
      echo "$msgstr"
      msgutil_r "$MASTER_IP"  "$msgtype" "$msgstr" "/var/log/xcat/xcat.log" "$log_label"
   fi

   #reload the functions defined in./xcatlib.sh
   if [ "$ismsgutil_r" = "0" ];then
       unset msgutil_r
       [ -f ./xcatlib.sh ] && source ./xcatlib.sh
   fi
}


download_postscripts()
{
    server=$1
    if [ -z $server ]; then
        return 1;
    fi

    # Do not override the parameter --installdir
    if [ -z "$INSTALLDIR" ]; then
        if [ -f /opt/xcat/xcatinfo ]; then
           INSTALLDIR=`grep 'INSTALLDIR' /opt/xcat/xcatinfo |cut -d= -f2`
        fi
        if [ -z "$INSTALLDIR" ]; then
            INSTALLDIR="/install"
        fi
    fi
    echolog "debug" "trying to download postscripts from http://$server$INSTALLDIR/postscripts/"
    max_retries=5
    retry=0
    rc=1  # this is a fail return
    while [ 0 -eq 0 ]; do
        if [ -e "$xcatpost" ]; then
            rm -rf "$xcatpost"
        fi

        export LANG=C; wget -l inf -nH -N -r --waitretry=10 --random-wait -e robots=off -T 60 -nH --cut-dirs=2 --reject "index.html*" --no-parent http://$server$INSTALLDIR/postscripts/ -P /$xcatpost 2> /tmp/wget.log
        rc=$?
        if [ $rc -eq 0 ]; then
            # return from wget was 0 but some OS do not return errors, so we
            # have additional checks for
            # failed: Connection httpd not running
            # 404: Not Found  - if directory does not exist
            grep -i -E "... failed: Connection refused.$" /tmp/wget.log
            rc1=$?
            grep -i -E "ERROR 404: Not Found.$" /tmp/wget.log
            rc2=$?
            # check to see no errors at all, grep returns 1
            if [ $rc1 -eq 1 ] && [ $rc2 -eq 1 ]; then
              echolog "debug" "postscripts are downloaded from $server successfully."
              return 0
            fi
        fi

        retry=$(($retry+1))
        echolog "debug" "download_postscripts retry $retry"
        if [ $retry -eq $max_retries ]; then
            echolog "debug" "failed to download postscripts from http://$server$INSTALLDIR/postscripts/ after several retries."
            break
        fi

        SLI=$(awk 'BEGIN{srand(); printf("%d\n",rand()*20)}')
        sleep $SLI
    done
    return $rc
}


download_mypostscript()
{
    server=$1
    node=$2
    max_retries=$3
    TFTPDIR=$4
    if [ -z $server ]; then
      return 1;
    fi
    if [ -z "$TFTPDIR" ]; then
        TFTPDIR="/tftpboot"
    fi
    retry=0
    rc=1


    echolog "debug" "trying to download http://$server$TFTPDIR/mypostscripts/mypostscript.$node..."
    while [ 0 -eq 0 ]; do
        wget -N --waitretry=10 --random-wait -T 60 http://$server$TFTPDIR/mypostscripts/mypostscript.$node -P /$xcatpost 2>> /tmp/wget.log
        rc=$?
        # if no error and the file  was downloaded
        if [ $rc -eq 0 ] && [ -f /$xcatpost/mypostscript.$node ]; then
            mv /$xcatpost/mypostscript.$node /$xcatpost/mypostscript
            echolog "debug" "mypostscript.$node is downloaded successfully."
            return 0
        fi


        retry=$(($retry+1))
        if [ $retry -eq $max_retries ]; then
            echolog "debug" "http://$server$TFTPDIR/mypostscripts/mypostscript.$node is not available."
            break
        fi

    done
    return $rc
}



# pmatch determines if 1st argument string is matched by 2nd argument pattern

pmatch ()
{
  case $1 in
    $2) return 0;;  # zero return code means string matched by pattern
  esac

  return 1          # non-zero return code means string not matched by pattern
}

#parse the http server "<ip/hostname>:<port>"
#usgae: parsehttpserver(<http server string>,<what to return? 'server' or 'port'>)
parsehttpserver ()
{
   rawserver=$1
   option=$2
   server=$(echo "$rawserver"|cut -d: -f1 -s 2>/dev/null)
   port="80"
   if [ -z "$server"  ];then
       server=$rawserver
   else
       port=$(echo "$rawserver"|cut -d: -f2 -s 2>/dev/null)
   fi

   if [ "$option" = "server" ];then
       echo "$server"
   fi

   if [ "$option" = "port" ];then
       echo "$port"
   fi
}

# Main
# parse the arguments
log_label="xcat.updatenode"
ARGNUM=$#;
if [ -z $1 ]; then
  NODE_DEPLOYMENT=1
  log_label="xcat.deployment"
else
  NODE_DEPLOYMENT=0
  case $1 in
    1|2|5)
      MODE=$1
      if [ $ARGNUM -gt 1 ]; then
        if [ $2 = "-m" ]; then
          P_SVR=$3
          P_SIP=$(parsehttpserver "$P_SVR" 'server')
          HTTPPORT=$(parsehttpserver "$P_SVR" 'port')
        else
          if [ $2 = "-M" ]; then
            P_SVR=$3
            P_SIP=$(parsehttpserver "$P_SVR" 'server')
            HTTPPORT=$(parsehttpserver "$P_SVR" 'port')
            new_ms=$P_SIP    # -M means we will update xcatinfo file XCATSERVER
          fi
        fi
      fi
      if [ $ARGNUM -gt 3 ]; then
        POSTSCRIPTS=$4
      fi
      if [ $ARGNUM -gt 4 ]; then
        if [ $5 = "--tftp" ]; then
          TFTPDIR=$6
        fi
      fi
      if [ $ARGNUM -gt 6 ]; then
        if [ $7 = "--installdir" ]; then
          INSTALLDIR=$8
        fi
      fi
      if [ $ARGNUM -gt 8 ]; then
        if [ $9 = "--nfsv4" ]; then
          NFSV4=${10}
        fi
      fi
      if [ $ARGNUM -gt 10 ]; then
        if [ ${11} = "-c" ]; then
          CFLAG=${11}
        fi
      fi
      if [ $ARGNUM -gt 11 ]; then
        if [ ${12} = "-V" ]; then
         export VERBOSE=1
        fi
        if [ ${12} = "-F" ]; then
         export USEFLOWCONTROL=1
        fi
      fi
      if [ $ARGNUM -gt 12 ]; then
        if [ ${13} = "-V" ]; then
         export VERBOSE=1
        fi
      fi
      ;;
    4)
      MODE=$1
      log_label="xcat.deployment"
      ;;
    3|6) MODE=$1;;
  esac
fi

# The cheat sheet for ${MODE}
# Empty
#   node deployment
# 1 - updatenode -P
#   Execute postscripts listed in the postscripts table or parameters
# 2 - updatenode -S
#   Perform Software Maintenanc - updatenode -S
# 3 - moncfg rmcmon
#   Obsoleted
# 4
#   Statelite mode
# 5
#   Update security
# 6 - xcatpostinit1
#   During node reboot
case "${MODE}" in
"1"|"2"|"5")
  # The cheat sheet for checkservicestatus
  # Return code
  # 0 - active
  # 1 - inactive
  # 2 - failed
  # 3 - others
  # 17 - activating
  # 127 - error
  checkservicestatus xcatpostinit1 >/dev/null 2>&1
  case "$?" in
  "17")
    echolog "warning" "xCAT post-booting process is not completed yet. Abort. Please try later."
    exit 255
    ;;
  esac
  ;;
esac

update_VPD()
{
    if [ -f /usr/sbin/vpdupdate ]; then
        echolog "info" "updating VPD database"
        vpdupdate
        #logger -t xCAT -p local4.info "xcatdsklspost: updating VPD database"
    else
        echolog "warning" "/usr/sbin/vpdupdate is not available, please check and do VPD update later"
    fi
}

if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
    # Run updatevpd only when necessary
    if [ -f /usr/sbin/lsvpd ]; then
        /usr/sbin/lsvpd | grep -i -E 'cpu|processor' 2>&1 1>/dev/null
        if [ "$?" = "1" ]; then
            update_VPD
        fi
    fi
fi

if [ $NODE_DEPLOYMENT -ne 1 ] && [ $MODE -ne 4 ] ; then
  echolog "info" "=============updatenode starting===================="
fi
# set the default path for the xcatpost directory
xcatpost="/xcatpost"
# Check for debug mode and you have nodename available you can change the path for debug

echolog "debug" "Running $0 $*"


if [ -n "$XCATDEBUG" ]; then
  if [ -n "$NODE" ]; then
     xcatpost="/xcatpost.$NODE"
  fi
fi
#echo "xcatpost = $xcatpost"

useflowcontrol=0
if [ "$USEFLOWCONTROL" = "1" ]; then
  useflowcontrol=1
fi
# from install kcmdline
if [ "$FC" = "1" ] || [ "$FC" = "yes" ] || [ "$FC" = "YES" ]; then
  useflowcontrol=1
fi


# If on AIX node
if [ ! `uname` = Linux ]; then
   #Get a new copy of xcataixpost on the node
   mkdir -p  /$xcatpost;
   mkdir -p  /xcatmnt;
   if [ "$NFSV4" = "yes" ]; then
         mount -o vers=4 $P_SIP:$INSTALLDIR/postscripts /xcatmnt
   else
         mount $P_SIP:$INSTALLDIR/postscripts /xcatmnt
   fi
   cp /xcatmnt/xcataixpost /$xcatpost
   umount /xcatmnt
   rmdir /xcatmnt
  logger -t xcat -p local4.err "Running xcataixpost $*"
  # note not supporting -F or -V on AIX
  echo "/$xcatpost/xcataixpost $1 $2 $3 '"$4"' $5 $6 $7 $8 $9 ${10} ${11}"
  exec /$xcatpost/xcataixpost $1 $2 $3 "$4" $5 $6 $7 $8 $9 ${10} ${11}
  exit
fi

#SLI=$(awk 'BEGIN{srand(); printf("%d\n",rand()*10)}')
#sleep $SLI

if [ ! -d /$xcatpost ]; then
    mkdir -p /$xcatpost;
fi

if [ ! -d /tmp/postage ]; then
    mkdir -p /tmp/postage
fi
rm -R -f /tmp/postage/*

#here we get all the postscripts.  Please do not change this behaviour because some scripts depend on others
cd /tmp/postage

echolog "info" "trying to download postscripts..."
if [ "$MODE" = "4" ]; then # for statelite mode
    # We have written the xCATSERVER info into the kernel command line!!
    for i in `cat /proc/cmdline`; do
        KEY=`echo $i | awk -F= '{print $1}'`
        if [ "$KEY" =  "XCAT" ]; then
            TMP=`echo $i | awk -F= '{print $2}'`
            XCATSERVER=`echo $TMP | cut -d: -f1`
            grep 'XCATSERVER' /opt/xcat/xcatinfo > /dev/null  2>&1
            if [ $? -eq 0 ]; then
                sed -i "s/XCATSERVER=.*/XCATSERVER=$XCATSERVER/" /opt/xcat/xcatinfo
            else
                echo "XCATSERVER=$XCATSERVER" >> /opt/xcat/xcatinfo
            fi
        elif [ "$KEY" =  "XCATHTTPPORT" ]; then
            HTTPPORT=`echo $i | awk -F= '{print $2}'`
            grep 'HTTPPORT' /opt/xcat/xcatinfo > /dev/null  2>&1
            if [ $? -eq 0 ]; then
                sed -i "s/HTTPPORT=.*/HTTPPORT=$HTTPPORT/" /opt/xcat/xcatinfo
            else
                echo "HTTPPORT=$HTTPPORT" >> /opt/xcat/xcatinfo
            fi
        fi
    done

    if [ -f /opt/xcat/xcatinfo ]; then
        SIP=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
        HTTPPORT=`grep 'HTTPPORT' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
        if [ -n "$SIP" ]; then
            download_postscripts $SIP:${HTTPPORT}
            if [ $? -eq 0 ]; then
                downloaded=1
            fi
        fi
    else
        #echo "xCAT management server IP can't be determined.";
        #echo "exiting...";
        #logger -t xCAT -p local4.err "xcatdsklspost:xCAT management server IP can't be determined.\nexiting...";
        echolog "err" "xCAT management server IP can't be determined.\nexiting..."
        exit;
    fi


else # for common mode  MODE=1,2,3,5 (updatenode,moncfg,node deployment)
    # non-Statelite MODE

    # If we have written the NODE info into the kernel command line,
    # put in in xcatinfo
    if [ ! -f /opt/xcat/xcatinfo ]; then
        mkdir -p /opt/xcat
        touch /opt/xcat/xcatinfo
    fi
    for i in `cat /proc/cmdline`; do
        KEY=`echo $i | awk -F= '{print $1}'`
        if [ "$KEY" =  "NODE" ]; then
            NODE=`echo $i | awk -F= '{print $2}'`
            break
        fi
    done
    if [ -z "$NODE" ]; then
         NODE=`hostname -s`
    fi

    downloaded=0;  #  have not downloaded the postscripts
    # try the -m/-M input (P_SIP) if it is specified,
    # -m/-M is passed in the updatenode command
    # and is the address of the xcatmaster for this node.  Using -M just means
    # also update the XCATSERVER in the /etc/xcat/xcatinfo file with this
    # address
    if [ -n "$P_SIP" ]; then   # passed in with updatenode on -M/-m
        #SIP="${P_SIP}:${HTTPPORT}"
        SIP=${P_SIP}
        download_postscripts ${P_SIP}:${HTTPPORT}
        if [ $? -eq 0 ]; then
            downloaded=1
        fi
    fi
    # if the download failed then, if not updatenode
    # open the xcatinfo file to look for an XCATSERVER address to try
    # if the address if not the same as the one on the -m/M flag then
    # try it
    if [ $downloaded -eq 0 ]; then

        # if this is an updatenode call, then stop trying and
        # return an error
        if [ "$MODE" = "1" ] || [ "$MODE" = "2" ] || [ "$MODE" = "5" ]; then # updatenode
            hn=`hostname`
            #echo "Cannot download the postscripts from $SIP  for $hn check /tmp/wget.log on the node."
            #logger -t xCAT -p local4.err "xcatdsklspost:Cannot download the postscripts from the xCAT server $SIP for node $hn check /tmp/wget.log on the node."
            echolog "err" "cannot download the postscripts from the xCAT server $SIP for node $hn check /tmp/wget.log on the node."
            exit
        fi

        # if not updatenode, then look in xcatinfo for the xcatmaster
        if [ -f /opt/xcat/xcatinfo ]; then
            SIP=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
            HTTPPORT=`grep 'HTTPPORT' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
            [ -z "$HTTPPORT" ] && HTTPPORT="80"
            if [ -n "$SIP" ]; then
                download_postscripts ${SIP}:${HTTPPORT}
                if [ $? -eq 0 ]; then
                  downloaded=1
                fi
            fi
        fi
    fi

    # download postscripts has not worked yet
    if [ $downloaded -eq 0 ]; then

         # for the non-updatenode calls try the host in the XCAT kernel param.
         for i in `cat /proc/cmdline`; do
             KEY=`echo $i | awk -F= '{print $1}'`
             if [ "$KEY" =  "XCAT" ]; then
                 TMP=`echo $i | awk -F= '{print $2}'`
                 SIP=`echo $TMP | cut -d: -f1`

             elif [ "$KEY" = "XCATHTTPPORT" ];then
                 HTTPPORT=$(echo $i | awk -F= '{print $2}')
                 [ -z "$HTTPPORT" ] && HTTPPORT="80"
             fi
         done

         if [ -n "$SIP" ]; then
             download_postscripts "${SIP}:${HTTPPORT}"
             if [ $? -eq 0 ]; then
                 downloaded=1
             fi
         fi
    fi

    # download poscripts has not worked yet
    #try the dhcp server, this is used for initial boot for the node.
    if [ $downloaded -eq 0 ]; then
        #setup $OSVER ,for SLES11
        if [ -e '/etc/SuSE-release' ]; then
            OSVER=`grep -h VERSION /etc/SuSE-release |awk '{print $3}'`
        fi
        SIPS=`grep -h dhcp-server-identifier /var/lib/dhclient/dhclient*eth*.leases 2> /dev/null|awk '{print $3}'|sed -e 's/;//'`
        if [ -z "$SIPS" ]; then
            SIPS=`grep -h dhcp-server-identifier /var/lib/dhclient/dhclient*hf*.leases 2> /dev/null|awk '{print $3}'|sed -e 's/;//'`
            if [ -z "$SIPS" ]; then
                SIPS=`grep -h DHCPSID /var/lib/dhcpcd/*.info 2> /dev/null|awk -F= '{print $2}'|sed -e s/\'//g`
            fi
        fi
        SIP=`echo $SIPS|awk '{printf $NF}' | tail -n 1` #Pick one for wget
        if [ -n "$SIP" ]; then
            download_postscripts $SIP
            if [ $? -eq 0 ]; then
                downloaded=1
            fi
        elif [ -x "/sbin/dhcpcd" ]; then
            # New dhcpcd doesn't creates *.info files.
            for lease in $(ls "/var/lib/dhcpcd/"); do
                iface="$(echo "$lease" | sed -n -e 's/^dhcpcd-\(.*\)\.lease$/\1/p')"
                if [ -n "$iface" ]; then
                    SIP="$(dhcpcd -q -T "$iface" | sed -n -e '/new_dhcp_server_identifier/ s/.*=//p')"
                    if [ -n "$SIP" ]; then
                        download_postscripts $SIP
                        if [ $? -eq 0 ]; then
                            downloaded=1
                            break
                        fi
                    fi
                fi
            done
        fi
    fi

    #no hope to download postscripts, now let's get out of here.
    if [ $downloaded -eq 0 ]; then
        hn=`hostname`
        #echo "Cannot download the postscripts from the xCAT server for node $hn"
        #logger -t xCAT -p local4.err "xcatdsklspost:Cannot download the postscripts from the xCAT server for node $hn"
        echolog "err" "failed to download the postscripts from the xCAT server for node $hn"
        exit 1
    else
        echolog "info" "postscripts downloaded successfully"
    fi

fi # finish the postscripts download

# remove the current mypostscript file
rm -rf /$xcatpost/mypostscript

# if NODE is exported ( updatenode call or from kernel parameter)
# use it as the nodename to get the mypostscript file.
if [ -n "$NODE" ]; then
  node_short=$NODE
else
  #get node name and download the mypostscript.$node file
  #try to get the node ip address that connects to the server.
  #then resolve the name of the ip
  real_SIP=`getent hosts $SIP |awk {'print $1'}`
  if [ $? -ne 0 ]; then
    real_SIP=$SIP
  fi

  NIP=`ip route get $real_SIP | head -n 1 | sed 's/^.*src//g' | awk {'print $1'}`
  if [ $? -eq 0 ] && [ -n "$NIP" ]; then
    #resolve the name of the node from ip address
    result=`getent hosts $NIP`
    if [ $? -eq 0 ]; then
      node1=`echo $result | awk {'print $2'}`
      node2=`echo $result | awk {'print $3'}`
      if [ ${#node1} -gt ${#node2} ]; then
        node=$node1
        node_short=$node2
      else
        node=$node2
        node_short=$node1
      fi
      if [ -z "$node_short" ]; then
        node_short=`echo $node |awk -F. {'print $1'}`
      fi
    else
      if [ -z "$node" ]; then
        node=`hostname`
        node_short=`hostname -s`
      fi
    fi
  else
    node=`hostname`
    node_short=`hostname -s`
  fi
fi

echolog "info" "trying to get mypostscript from $SIP..."
max_retries=2
# try short hostname first
if [ -n "$node_short" ]; then
    download_mypostscript "${SIP}:${HTTPPORT}" $node_short $max_retries $TFTPDIR
    if [ $? -ne 0 ]; then
        # try long hostname
        if [ "$node" != "$node_short" ]; then
          download_mypostscript "${SIP}:${HTTPPORT}" $node $postfix $max_retries $TFTPDIR
        fi
    fi
fi

# on reboot and shutdown, make sure /ro and /rw are not stuck mounted
if grep 'rw /rw tmpfs ' /proc/mounts  >/dev/null 2>&1; then
    touch /var/lock/subsys/xcatmounts
    echo '#!/bin/bash' > /etc/rc6.d/K10xcatmounts
    echo umount -l /ro >> /etc/rc6.d/K10xcatmounts
    echo umount -l /rw >> /etc/rc6.d/K10xcatmounts
    chmod 755 /etc/rc6.d/K10xcatmounts
    ln -sf /etc/rc6.d/K10xcatmounts /etc/rc0.d/K10xcatmounts
fi

# To support the postscripts in the subdirectories under /install/postscripts
#chmod +x /$xcatpost/*;
chmod -R +x `find $xcatpost/ -maxdepth 1 -print | grep -E -v "^($xcatpost/|$xcatpost/_xcat|$xcatpost/_ssh|$xcatpost/ca|$xcatpost/hostkeys)$"`

cd /$xcatpost;
PATH=/$xcatpost:$PATH
export PATH

if [ -x /usr/bin/openssl ]; then
     XCATSERVER="$SIP:3001"
     export XCATSERVER
     USEOPENSSLFORXCAT=1 #Though this is the only method going forward, flag to allow backward compatibility with 2.2 generated netboot images
     export USEOPENSSLFORXCAT
fi

# if download of postscript failed,
# probably  the /tftpboot/mypostcript/mypostscript.<nodename> does not exist.
# We need to call getpostscript.awk .

if [ ! -x /$xcatpost/mypostscript ]; then
  echolog "debug" "no pre-generated mypostscript.<nodename>, trying to get it with getpostscript.awk..."
  if [ $useflowcontrol = "1" ]; then
    # first contact daemon  xcatflowrequest <server> 3001
    #logger -t xCAT -p local4.info "xcatdsklspost:sending xcatflowrequest $SIP 3001"
    echolog "debug" "sending xcatflowrequest $SIP 3001"
    /$xcatpost/xcatflowrequest $SIP 3001
    rc=$?
    #logger -t xCAT -p local4.info "xcatdsklspost:xcatflowrequest return=$rc"
    echolog "debug" "xcatflowrequest return=$rc"
    if [ $rc -ne 0 ]; then
      #logger -t xCAT -p local4.info "xcatdsklspost: error from xcatflowrequest, will not use flow control"
      echolog "debug" "error from xcatflowrequest, will not use flow control"
      useflowcontrol=0
    fi
  fi
  /$xcatpost/getpostscript.awk | egrep  '<data>' | sed  -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" >  /$xcatpost/mypostscript;


 MYCONT=`grep MASTER /$xcatpost/mypostscript`
 MAX_RETRIES=10
 RETRY=0
 while [ -z "$MYCONT" ]; do
    # not using flow control , need to sleep
    if [ $useflowcontrol = "0" ]; then
        let SLI=$RANDOM%10
        let SLI=SLI+10
        sleep $SLI
    fi

    RETRY=$(($RETRY+1))
    if [ $RETRY -eq $MAX_RETRIES ]
    then
        break
    fi

    if [ $useflowcontrol = "1" ]; then
      # contact daemon  xcatflowrequest <server> 3001
      #logger -t xCAT -p local4.info "xcatdsklspost: sending xcatflowrequest $SIP 3001"
      echolog "debug" "sending xcatflowrequest $SIP 3001"
      /$xcatpost/xcatflowrequest $SIP 3001
      rc=$?
      #logger -t xCAT -p local4.info "xcatdsklspost:xcatflowrequest return=$rc"
      echolog "debug" "xcatflowrequest return=$rc"
      if [ $rc -ne 0 ]; then
        #logger -t xCAT -p local4.info "xcatdsklspost: error from xcatflowrequest, will not use flow control"
        echolog "debug" "error from xcatflowrequest, will not use flow control"
        useflowcontrol=0
      fi
    fi
    /$xcatpost/getpostscript.awk | egrep  '<data>' | sed  -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" >  /$xcatpost/mypostscript;
    MYCONT=`grep MASTER /$xcatpost/mypostscript`
    if [ ! -z "$MYCONT" ]; then
        break;
    fi
 done
fi

#save the MASTER into the xcatinfo file for node deployment case,
#for updatenode case, only save it when -M is specified
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ]; then
    new_ms=`grep '^MASTER' /$xcatpost/mypostscript |head -n 1 |cut -d= -f2`
fi
if [ -n "$new_ms" ]; then
    if [ ! -f /opt/xcat/xcatinfo ]; then
      mkdir -p /opt/xcat
      touch /opt/xcat/xcatinfo
    fi
    grep 'XCATSERVER' /opt/xcat/xcatinfo > /dev/null  2>&1
    if [ $? -eq 0 ]; then
      sed -i "s/XCATSERVER=.*/XCATSERVER=$new_ms/" /opt/xcat/xcatinfo
    else
      echo "XCATSERVER=$new_ms" >> /opt/xcat/xcatinfo
    fi

    grep 'HTTPPORT' /opt/xcat/xcatinfo > /dev/null  2>&1
    if [ $? -eq 0 ]; then
      sed -i "s/HTTPPORT=.*/HTTPPORT=$HTTPPORT/" /opt/xcat/xcatinfo
    else
      echo "HTTPPORT=$HTTPPORT" >> /opt/xcat/xcatinfo
    fi
fi

#save the USEFLOWCONTROL into the xcatinfo file
#for updatenode case, passwd in with the -f flag
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ]; then
    useflowcontrol=`grep '^USEFLOWCONTROL' /$xcatpost/mypostscript |cut -d= -f2 | tr -d \'\" | tr A-Z a-z`
fi
if [ ! -f /opt/xcat/xcatinfo ]; then
  mkdir -p /opt/xcat
  touch /opt/xcat/xcatinfo
fi
if [ -n "$useflowcontrol" ]; then
    # lets just put YES or NO in xcatinfo
    if [[ "$useflowcontrol" =~ ^(1|yes|y)$ ]]; then
       new_fc="YES"
    else
       new_fc="NO"
    fi
# no setting means do not use flowcontrol
else
    new_fc="NO"
fi
grep 'USEFLOWCONTROL' /opt/xcat/xcatinfo > /dev/null  2>&1
if [ $? -eq 0 ]; then
    sed -i "s/USEFLOWCONTROL=.*/USEFLOWCONTROL=$new_fc/" /opt/xcat/xcatinfo
else
    echo "USEFLOWCONTROL=$new_fc" >> /opt/xcat/xcatinfo
fi

# Add Node name to /opt/xcat/xcatinfo
if [ -z "$NODE" ]; then
    NODE=`hostname -s`
fi
grep 'NODE' /opt/xcat/xcatinfo > /dev/null  2>&1
if [ $? -eq 0 ]; then
    sed -i "s/NODE=.*/NODE=$NODE/" /opt/xcat/xcatinfo
else
    echo "NODE=$NODE" >> /opt/xcat/xcatinfo
fi


# Store the SERVICEGROUP into the xcatinfo file for node deployment, and also for updatenode -s
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "1" ]; then
    sn_group=`grep '^SERVICEGROUP' /$xcatpost/mypostscript |cut -d= -f2 | tr -d \'\"`
    if [ "x" != "x$sn_group" ]; then
      # Change or add SERVICEGROUP line if service node pool defined.
      grep 'SERVICEGROUP=' $XCATINFOFILE > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        sed -i "s/SERVICEGROUP=.*/SERVICEGROUP=$sn_group/" $XCATINFOFILE
      else
        echo "SERVICEGROUP=$sn_group" >> $XCATINFOFILE
      fi
    else
      # Remove SERVICEGROUP line if no service node pool defined.
      sed -i "/SERVICEGROUP=.*/d" $XCATINFOFILE
    fi
fi

# when called by the updatenode command  MODE=1,2
# the nodename is passed in by xdsh in the NODE environment variable by xdsh.

#modify the UPDATENODE flag to 1
# put NODE in /opt/xcat/xcatinfo
if [ "$MODE" = "1" ] || [ "$MODE" = "2" ]; then
  TMP=`sed -e 's/UPDATENODE=0/UPDATENODE=1/g' /$xcatpost/mypostscript`;
  echo "$TMP" > /$xcatpost/mypostscript;
  if [ ! -f /opt/xcat/xcatinfo ]; then
    mkdir -p /opt/xcat
    touch /opt/xcat/xcatinfo
  fi
  if [ -z "$NODE" ]; then
    NODE=`hostname -s`
  fi
  grep 'NODE' /opt/xcat/xcatinfo > /dev/null  2>&1
  if [ $? -eq 0 ]; then
    sed -i "s/NODE=.*/NODE=$NODE/" /opt/xcat/xcatinfo
  else
    echo "NODE=$NODE" >> /opt/xcat/xcatinfo
  fi
#echo "xcatdsklspost:my nodename in the database is $NODE"
fi
if [ "$MODE" = "5" ]; then
  TMP=`sed -e 's/UPDATENODE=0/UPDATENODE=1\nUPDATESECURITY=1\nexport UPDATESECURITY/g' /$xcatpost/mypostscript`;
  echo "$TMP" > /$xcatpost/mypostscript;
fi

#when a diskfull reboot mode
if [ "$MODE" = "6" ]; then
  # remove the post scripts so that they are not run on reboot
  TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
  echo "$TMP" > /$xcatpost/mypostscript
  # get the RUNBOOTSCRIPTS site variable
  if [ -f /$xcatpost/mypostscript ]; then
    RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /$xcatpost/mypostscript |cut -d= -f2 | tr -d \'\" | tr A-Z a-z `
  fi

  # if admin did not requested running of post boot scripts - then remove PBS
  if [[ !  "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
  #remove all the postscripts
  TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
  echo "$TMP" > /$xcatpost/mypostscript

  #TMP=`sed "/postbootscripts-start-here/,/postbootscripts-end-here/ d" /$xcatpost/mypostscript.post`
  #echo "$TMP" > /$xcatpost/mypostscript.post
  fi
fi

# postscript name is specified with the updatenode
#cp /$xcatpost/mypostscript /$xcatpost/mypostscript.backup
# if the list has a postscript named *start-here* then we must rebuild the
# mypostscript file with only the matching *start-here stanza.


if ( pmatch $POSTSCRIPTS  "*start-here*" ); then
  if ( pmatch $POSTSCRIPTS  "*osimage-postbootscripts-start-here" ); then
  # remove all sections but the osimage-postbootscripts section
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# defaults-postbootscripts-start-here/,/# defaults-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# node-postbootscripts-start-here/,/# node-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi
  if ( pmatch $POSTSCRIPTS  "*postscripts-start-here" ); then
    #remove all the postbootscripts
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi
  if ( pmatch $POSTSCRIPTS  "*postbootscripts-start-here" ); then
    #remove all the postscripts
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript

  fi
  if ( pmatch $POSTSCRIPTS  "*defaults-postscripts-start-here" ); then
  # remove all sections but the defaults-postscripts section
    TMP=`sed "/# osimage-postscripts-start-here/,/# osimage-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# node-postscripts-start-here/,/# node-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi

  if ( pmatch $POSTSCRIPTS  "*node-postscripts-start-here" ); then
  # remove all sections but the node-postscripts section
    TMP=`sed "/# osimage-postscripts-start-here/,/# osimage-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# defaults-postscripts-start-here/,/# defaults-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi

  if ( pmatch $POSTSCRIPTS  "*defaults-postbootscripts-start-here" ); then
  # remove all sections but the defaults-postbootscripts section
    TMP=`sed "/# osimage-postbootscripts-start-here/,/# osimage-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# node-postbootscripts-start-here/,/# node-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi


  if ( pmatch $POSTSCRIPTS  "*node-postbootscripts-start-here" ); then
  # remove all sections but the node-postbootscripts section
    TMP=`sed "/# osimage-postbootscripts-start-here/,/# osimage-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# defaults-postbootscripts-start-here/,/# defaults-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi


# check to see if input postscript list is not empty. If there is a list
# remove the built postscripts and only add the ones for the list.
else
   if [ -n "$POSTSCRIPTS" ]; then
    #remove all the postbootscripts, and replace with list provided
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    #remove all the postscripts
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    echo "# postscripts-start-here" >> /$xcatpost/mypostscript
    #add requested postscripts in
    echo "$POSTSCRIPTS" | tr "," "\n" >> /$xcatpost/mypostscript
    echo "# postscripts-end-here" >> /$xcatpost/mypostscript

  fi
fi

#ADDSITEYUM is set by post.rh and post.rh.iscsi for full installtion
#if [[ "$ADDSITEYUM" = "1" ]]; then
#  TMP=`sed "/postscripts-start-here/ a addsiteyum" /$xcatpost/mypostscript`
#  echo "$TMP" > /$xcatpost/mypostscript
#fi

#MYCONT=`cat /$xcatpost/mypostscript`
#echo "$MYCONT"

# use the run_ps subroutine to run the postscripts
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ s/\(.*\)/run_ps postbootscript \1/;s/run_ps postbootscript\s*#/#/;s/run_ps postbootscript\s*$//" /$xcatpost/mypostscript`
else
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ s/\(.*\)/run_ps postscript \1/;s/run_ps postscript\s*#/#/;s/run_ps postscript\s*$//" /$xcatpost/mypostscript`
fi
echo "#!/bin/bash
. /xcatpost/xcatlib.sh

# global value to store the running status of the postbootscripts,the value is non-zero if one postbootscript failed
return_value=0
# subroutine used to run postscripts
# \$1 argument is the script type
# rest argument is the script name and arguments
run_ps () {
 local ret_local=0
 mkdir -p "\"/var/log/xcat\""
 local logfile=\"/var/log/xcat/xcat.log\"
 local scriptype=\$1
 shift;

 if [ -z \"\$scriptype\" ]; then
  scriptype=\"postscript\"
 fi
 if [ \$UPDATENODE -eq 0 ]; then
     log_label=\"xcat.deployment.\"\$scriptype
 else
     log_label=\"xcat.updatenode.\"\$scriptype
 fi
 export LOGLABEL=\$log_label
 if [ -f \$1 ]; then
  echo \"\$scriptype start..: \$1\"
  msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype start..: \$1\"" \"\$logfile\" \"\$log_label\"
  if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
     local compt=\$(file \$1)
     local reg=\"shell script\"
     if [[ \"\$compt\" =~ \$reg ]]; then
        bash -x ./\$@ 2>&1 | tee -a \$logfile | tee >(logger -t \$log_label -p debug)
        ret_local=\${PIPESTATUS[0]}
     else
        ./\$@ 2>&1 | tee -a \$logfile | tee >(logger -t \$log_label -p debug)
        ret_local=\${PIPESTATUS[0]}
     fi
  else
     ./\$@ 2>&1 | tee -a \$logfile
     ret_local=\${PIPESTATUS[0]}
  fi

  if [ \"\$ret_local\" -ne \"0\" ]; then
     return_value=\$ret_local
  fi
  echo \"\$scriptype end....: \$1 exited with code \$ret_local\"
  msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype end...:\$1 return with \$ret_local\"" \"\$logfile\" \"\$log_label\"
 else
  echo \"\`date\` \$scriptype \$1 does NOT exist.\"
  msgutil_r \"\$MASTER_IP\" \"error\" "\"\$scriptype \$1 does NOT exist.\"" \"\$logfile\" \"\$log_label\"
  return_value=-1
 fi

 return 0
}
# subroutine end

" > /$xcatpost/mypostscript
echo "$TMP" >> /$xcatpost/mypostscript
if [ "$MODE" = "1" ] || [ "$MODE" = "2" ]  || [ "$MODE" = "3" ] || [ "$MODE" = "5" ]; then
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ s/\(.*\)/run_ps postscript \1/;s/run_ps postscript\s*#/#/;s/run_ps postscript\s*$//" /$xcatpost/mypostscript`
else
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ s/\(.*\)/run_ps postbootscript \1/;s/run_ps postbootscript\s*#/#/;s/run_ps postbootscript\s*$//" /$xcatpost/mypostscript`
fi
echo "$TMP" > /$xcatpost/mypostscript

if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
  #notify the server that we are done with netbooting
  CNS=`grep NODESTATUS= /$xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z`
  if [ -z "$CNS" ] || [[ "$CNS" =~ ^(1|yes|y)$  ]]; then
# TMP=`sed "/postscripts-start-here/ i\updateflag.awk \\$MASTER 3002 \\"installstatus configuring\\"" /$xcatpost/mypostscript`
#       echo "$TMP"> /$xcatpost/mypostscript
    if [ "$MODE" = "6" ]; then
        echo "
if [ \"\$return_value\" -eq \"0\" ]; then
    msgutil_r \$MASTER_IP \"debug\" \"node booted successfully, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus booted\"
else
    msgutil_r \$MASTER_IP \"debug\" \"node boot failed, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus failed\"
fi
        " >> /$xcatpost/mypostscript
    else
        echo "
if [ \"\$return_value\" -eq \"0\" ]; then
    msgutil_r \$MASTER_IP \"debug\" \"node booted successfully, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus booted\"
    msgutil_r \$MASTER_IP \"info\" \"provision completed.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
else
    msgutil_r \$MASTER_IP \"debug\" \"node boot failed, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus failed\"
    msgutil_r \$MASTER_IP \"error\" \"provision completed with error.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
fi
        " >> /$xcatpost/mypostscript
    fi
  fi
fi

DHCP_TMP=`sed 's/\(DHCPINTERFACES=\)\(.*\)$/\1"\2"/' /$xcatpost/mypostscript`
echo "$DHCP_TMP" > /$xcatpost/mypostscript

CLEANUPXCATPOST=`grep CLEANUPXCATPOST= /$xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z`
if [[ "$CLEANUPXCATPOST" =~ ^(1|yes|y)$ ]]; then
  echo "cd /" >> /$xcatpost/mypostscript
  # /xcatpost might be read-only for statelite nodes
  echo "rm -rf /$xcatpost/*" >> /$xcatpost/mypostscript
fi



if [ "$MODE" = "1" ] || [ "$MODE" = "2" ] || [ "$MODE" = "5" ]; then
  echo "exit \$return_value" >> /$xcatpost/mypostscript
fi

chmod 700 /$xcatpost/mypostscript
if [ -x /$xcatpost/mypostscript ];then
   echolog "debug" "Running /$xcatpost/mypostscript"
   /$xcatpost/mypostscript
   VRET_POST=$?
   echolog "debug" "/$xcatpost/mypostscript return with $VRET_POST"
fi

#tell user it is done when this is called by updatenode command
if [ "$MODE" = "1" ] || [ "$MODE" = "2" ] || [ "$MODE" = "5" ]; then
  echo "returned from postscript"
  echolog "info" "=============updatenode ending===================="
fi

if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
  echolog "info" "=============deployment ending===================="
fi

exit $VRET_POST
EOF
chmod 755 /opt/xcat/xcatdsklspost

if [ ! -x /opt/xcat/xcatdsklspost ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate /opt/xcat/xcatdsklspost" "/var/log/xcat/xcat.log" "$log_label"
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "/opt/xcat/xcatdsklspost generated" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


#create the preboot script and run here
TMP=`sed "/^#\s*postbootscripts-start-here/,/^#\s*postbootscripts-end-here/ d" /xcatpost/mypostscript`
echo "$TMP" > /xcatpost/mypostscript

echo "
#save bad return code to /opt/xcat/xcatinfo
if [ \"\$return_value\" -ne \"0\" ]; then
    grep 'POSTSCRIPTS_RC' /opt/xcat/xcatinfo > /dev/null 2>&1
    if [ \$? -eq 0 ]; then
        sed -i \"s/POSTSCRIPTS_RC=.*/POSTSCRIPTS_RC=1/\" /opt/xcat/xcatinfo
    else
        echo \"POSTSCRIPTS_RC=1\" >> /opt/xcat/xcatinfo
    fi
fi
" >> /xcatpost/mypostscript

chmod 700 /xcatpost/mypostscript

export ARCH=x86_64
export CONSOLEPORT=0

#for redhat:
#place-holder for the code to save the repo info on compute node,pointing to the "pkgdir" of the osimage
#so that the provisioned node has the repo pointed to the distro path on MN

cat >/etc/yum.repos.d/local-repository-0.repo << 'EOF'
[local-centos7.9-x86_64--install-centos7.9-x86_64]
name=xCAT configured yum repository for /install/centos7.9/x86_64
baseurl=http://192.168.122.1:80//install/centos7.9/x86_64
enabled=1
gpgcheck=0


EOF


if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
   msgutil_r "$MASTER_IP" "info" "running mypostscript" "/var/log/xcat/xcat.log" "$log_label"
fi
/xcatpost/mypostscript
if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
   msgutil_r "$MASTER_IP" "info" "mypostscript returned" "/var/log/xcat/xcat.log" "$log_label"
fi


if [[ $OSVER == ubuntu* ]]; then
    if [[ -r /boot/grub/menu.lst ]]; then
        sed -i 's/^serial/#serial/' /boot/grub/menu.lst
        sed -i 's/^terminal/#terminal/' /boot/grub/menu.lst
    elif [[ -r /boot/grub/grub.cfg ]] ; then
        update-grub
    fi

    #print the kernel messages and service start messages with systemd on the console during system bootup
    [ -f /etc/default/grub ] && sed -i -e '/GRUB_CMDLINE_LINUX_DEFAULT=/s/quiet//;s/splash//' -e '/#GRUB_TERMINAL=/s/#//' -e 's/#GRUB_GFXMODE=.*/GRUB_GFXMODE=text/' /etc/default/grub && update-grub

    if echo "$ARCH" | grep -i 'x86_64'; then
        #grab the install-time console configuration from /proc/cmdline inside os installer
        CONSOLECFG=$(awk 'BEGIN{RS="[ \n]" ;ORS=" "} $0 ~ /^console=/{print $0}' /proc/cmdline)
        #if the console configuration is not applied to the grub configuration,apply it
        cat /boot/grub/grub.cfg |grep "$CONSOLECFG" >/dev/null 2>&1 || ([ -f /etc/default/grub ] && sed -i -e "/GRUB_CMDLINE_LINUX_DEFAULT=/s/=\"/=\" $CONSOLECFG /" /etc/default/grub && update-grub)
    fi
    if echo "$ARCH" | grep -i 'ppc64'; then
        if [ -z "$CONSOLEPORT" ] ; then
            export CONSOLEPORT=0
        fi
        CONSOLE="hvc$CONSOLEPORT"
        if [[ -r /etc/default/grub ]] ; then
            sed -i "s/GRUB_CMDLINE_LINUX_DEFAULT=.*/GRUB_CMDLINE_LINUX_DEFAULT=\"console=$CONSOLE\"/" /etc/default/grub
        else
            echo "GRUB_CMDLINE_LINUX_DEFAULT=\"console=$CONSOLE\"" > /etc/default/grub
        fi
        update-grub

cat >/etc/init/$CONSOLE\.conf << 'EOF'
start on stopped rc RUNLEVEL=[2345] and (
         not-container or
         container CONTAINER=lxc or
         container CONTAINER=lxc-libvirt)

stop on runlevel [!2345]
respawn
#exec /sbin/getty -L 115200 hvc0 vt102
script
    for i in `cat /proc/cmdline`; do
        KEY=`echo $i|cut -d= -f 1`
        if [ "$KEY" == "console" -a "$i" != "console=tty0" ]; then
            VALUE=`echo $i | awk -F= '{print $2}'`
            COTTY=`echo $VALUE|awk -F, '{print $1}'`
            COSPEED=`echo $VALUE|awk -F, '{print $2}'|awk -Fn '{print $1}'`

            break
        fi
    done

    exec /sbin/getty -L $COSPEED $COTTY vt102
end script
EOF
    fi
    sed -i '/127.0.1.1/d' /etc/hosts
else
    [ -f /boot/grub/grub.conf  ] && sed -i 's/^serial/#serial/' /boot/grub/grub.conf
    [ -f /boot/grub/grub.conf  ] && sed -i 's/^terminal/#terminal/' /boot/grub/grub.conf
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
       msgutil_r "$MASTER_IP" "debug" "/boot/grub/grub.conf updated" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


msgutil_r "$MASTER_IP" "info" "finished firstboot preparation, sending request to $MASTER:3002 for changing status..." "/var/log/xcat/xcat.log" "$log_label"
#the following command should always be run to prevent infinite installation loops
updateflag.awk $MASTER 3002

cd /

# fix the issue#929@github, the "service network restart" in <sles post scripts>
# makes the 'network' service in start status, then it causes the
# services YaST2-Second-Stage.service and xcatpostinit1 services to be run in parallel.
# But the YaST2-Second-Stage.service calls the Yast2 which conflics with the zypper
# which is called in xcatpostinit1->otherpkgs.
# The correct services start order is 'YaST2-Second-Stage.service'->'network'->'xcatpostinit1' in serial.
# To skip the conflict, the network service should be stoped in the yast first stage. Then base on the service
# dependency, the service start order will be 'YaST2-Second-Stage.service'->'network'->'xcatpostinit1' in serial.
# Then the Yast2 will be stopped before running the zypper in otherpkgs.
if [[ $OSVER =~ sle && $OSVER != sles11* ]]; then
    service network stop
fi

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set +x
fi
#the nic name might change between the installation and 1st boot
#active all the nics with network link during system boot


[ $XCATDEBUGMODE ] || export XCATDEBUGMODE=""
[ $MASTER_IP ] || export MASTER_IP="192.168.122.1"
declare -F msgutil_r &>/dev/null  || function msgutil_r {
   local logserver=$1
   local msgtype=$2
   local msgstr=$3
   local logfile=$4
   local logtag=$5

   if [ -z "$msgtype"  ]; then
      msgtype="debug"
   fi

   if [ -z "$logtag" ]; then
      logtag="xcat"
   fi

   if [ -n "$logserver" ];then
      logger -n $logserver -t $logtag -p local4.$msgtype "$msgstr"
      if [ "$?" != "0" ];then
         exec 3<>/dev/udp/$logserver/514 >/dev/null;logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&3
         if [ "$?" != "0" ];then
            logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&1|nc $logserver 514 >/dev/null 2>&1
            if [ "$?" != "0" ];then
               logger -t $logtag -p local4.$msgtype "$msgstr"
            fi
         fi
      fi
   else
       logger -t $logtag -p local4.$msgtype "$msgstr"
   fi
   if [ -n "$logfile"  ]; then
      local logdir="$(dirname $logfile)"
      if [ ! -d "$logdir" ]; then
         mkdir -p "$logdir"
         touch "$logfile"
      fi

      echo "$(date) [$msgtype]: $logtag: $msgstr" >> $logfile
   fi

}

declare -F msgutil &>/dev/null  || function msgutil {
    msgutil_r "" "$@"
}


for i in $(find /etc/sysconfig/network-scripts/ifcfg-*|egrep -v ifcfg-lo )
do
  nicname=$(echo $i|awk -F 'ifcfg-' '{print $2}')
  if ethtool $nicname|grep -E -i "Link detected.*yes" >/dev/null 2>&1; then
     if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "info" "set NIC $nicname to be activated on system boot" "/var/log/xcat/xcat.log"
     fi
     sed -i 's/ONBOOT=no/ONBOOT=yes/' $i
  fi

  #remove the entry 'HWADDR' from ifcfg-ethx, this is used to skip the
  #nic name change during the install and first_reboot
  sed -i '/HWADDR/d' $i
done

# NetworkManager will conflict with the configuring xcat do later in postboot script, so disable it in postscript

# There are 2 other service related to NetworkManager: NetworkManager-dispatcher and NetworkManager-wait-online
# Both of them are triggered by NetworkManager, so just disable NetworkManager here
if [ -f "/usr/lib/systemd/system/NetworkManager.service" ]; then
    systemctl disable NetworkManager
fi
} &>>/var/log/xcat/xcat.log
%end
